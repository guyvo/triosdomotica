
C:\cortex\dimmers\hex\tasks.o:     file format elf32-littlearm
C:\cortex\dimmers\hex\tasks.o


Disassembly of section .text.xTaskCreate:

00000000 <xTaskCreate>:
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:358
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4683      	mov	fp, r0
prvAllocateTCBAndStack():
C:\cortex\dimmers\rtos\src/tasks.c:1788
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   6:	2048      	movs	r0, #72	; 0x48
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:358
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
   8:	460d      	mov	r5, r1
   a:	4614      	mov	r4, r2
   c:	4698      	mov	r8, r3
   e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  10:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
prvAllocateTCBAndStack():
C:\cortex\dimmers\rtos\src/tasks.c:1788
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  14:	f7ff fffe 	bl	0 <pvPortMalloc>
C:\cortex\dimmers\rtos\src/tasks.c:1790

	if( pxNewTCB != NULL )
  18:	4606      	mov	r6, r0
  1a:	2800      	cmp	r0, #0
  1c:	f000 80a0 	beq.w	160 <xTaskCreate+0x160>
C:\cortex\dimmers\rtos\src/tasks.c:1795
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
  20:	ea4f 0984 	mov.w	r9, r4, lsl #2
  24:	4648      	mov	r0, r9
  26:	f7ff fffe 	bl	0 <pvPortMalloc>
  2a:	6330      	str	r0, [r6, #48]	; 0x30
C:\cortex\dimmers\rtos\src/tasks.c:1797

		if( pxNewTCB->pxStack == NULL )
  2c:	b918      	cbnz	r0, 36 <xTaskCreate+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:1800
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );			
  2e:	4630      	mov	r0, r6
  30:	f7ff fffe 	bl	0 <vPortFree>
  34:	e094      	b.n	160 <xTaskCreate+0x160>
C:\cortex\dimmers\rtos\src/tasks.c:1806
			pxNewTCB = NULL;			
		}		
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
  36:	21a5      	movs	r1, #165	; 0xa5
  38:	464a      	mov	r2, r9
  3a:	f7ff fffe 	bl	0 <memset>
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1674


static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
  3e:	4629      	mov	r1, r5
  40:	2210      	movs	r2, #16
  42:	f106 0034 	add.w	r0, r6, #52	; 0x34
  46:	f7ff fffe 	bl	0 <strncpy>
C:\cortex\dimmers\rtos\src/tasks.c:1690
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  4a:	1d35      	adds	r5, r6, #4
C:\cortex\dimmers\rtos\src/tasks.c:1675

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
  4c:	2f04      	cmp	r7, #4
  4e:	bf34      	ite	cc
  50:	463b      	movcc	r3, r7
  52:	2304      	movcs	r3, #4
  54:	f04f 0900 	mov.w	r9, #0
C:\cortex\dimmers\rtos\src/tasks.c:1683
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
  58:	62f3      	str	r3, [r6, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1686
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  5a:	6473      	str	r3, [r6, #68]	; 0x44
C:\cortex\dimmers\rtos\src/tasks.c:1675

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
  5c:	f886 9043 	strb.w	r9, [r6, #67]	; 0x43
C:\cortex\dimmers\rtos\src/tasks.c:1690
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  60:	4628      	mov	r0, r5
  62:	9301      	str	r3, [sp, #4]
  64:	f7ff fffe 	bl	0 <vListInitialiseItem>
C:\cortex\dimmers\rtos\src/tasks.c:1691
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  68:	f106 0018 	add.w	r0, r6, #24
  6c:	f7ff fffe 	bl	0 <vListInitialiseItem>
C:\cortex\dimmers\rtos\src/tasks.c:1698
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  70:	9b01      	ldr	r3, [sp, #4]
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:379
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if portSTACK_GROWTH < 0
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
  72:	1e60      	subs	r0, r4, #1
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1698
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  74:	f1c3 0305 	rsb	r3, r3, #5
  78:	61b3      	str	r3, [r6, #24]
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:379
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if portSTACK_GROWTH < 0
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
  7a:	6b33      	ldr	r3, [r6, #48]	; 0x30
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  7c:	4659      	mov	r1, fp
  7e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  82:	4642      	mov	r2, r8
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1695
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  84:	6136      	str	r6, [r6, #16]
C:\cortex\dimmers\rtos\src/tasks.c:1699

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  86:	6276      	str	r6, [r6, #36]	; 0x24
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  88:	f7ff fffe 	bl	0 <pxPortInitialiseStack>
C:\cortex\dimmers\rtos\src/tasks.c:402

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
  8c:	4c37      	ldr	r4, [pc, #220]	; (16c <xTaskCreate+0x16c>)
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  8e:	6030      	str	r0, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:400

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
  90:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:402
		{
			uxCurrentNumberOfTasks++;
  94:	6823      	ldr	r3, [r4, #0]
  96:	f104 0b08 	add.w	fp, r4, #8
  9a:	3301      	adds	r3, #1
  9c:	6023      	str	r3, [r4, #0]
C:\cortex\dimmers\rtos\src/tasks.c:403
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  9e:	6823      	ldr	r3, [r4, #0]
  a0:	2b01      	cmp	r3, #1
  a2:	d129      	bne.n	f8 <xTaskCreate+0xf8>
C:\cortex\dimmers\rtos\src/tasks.c:406
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
  a4:	6066      	str	r6, [r4, #4]
prvInitialiseTaskLists():
C:\cortex\dimmers\rtos\src/tasks.c:1721
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  a6:	2014      	movs	r0, #20
  a8:	fb00 b009 	mla	r0, r0, r9, fp
C:\cortex\dimmers\rtos\src/tasks.c:1719

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  ac:	f109 0901 	add.w	r9, r9, #1
C:\cortex\dimmers\rtos\src/tasks.c:1721
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  b0:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1719

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  b4:	f1b9 0f05 	cmp.w	r9, #5
C:\cortex\dimmers\rtos\src/tasks.c:1721
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  b8:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 16c <xTaskCreate+0x16c>
C:\cortex\dimmers\rtos\src/tasks.c:1719

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  bc:	d1f3      	bne.n	a6 <xTaskCreate+0xa6>
C:\cortex\dimmers\rtos\src/tasks.c:1724
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  be:	f108 036c 	add.w	r3, r8, #108	; 0x6c
  c2:	4618      	mov	r0, r3
C:\cortex\dimmers\rtos\src/tasks.c:1725
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  c4:	f108 0980 	add.w	r9, r8, #128	; 0x80
C:\cortex\dimmers\rtos\src/tasks.c:1724
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  c8:	9301      	str	r3, [sp, #4]
  ca:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1725
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  ce:	4648      	mov	r0, r9
  d0:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1726
	vListInitialise( ( xList * ) &xPendingReadyList );
  d4:	f108 0094 	add.w	r0, r8, #148	; 0x94
  d8:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1730

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  dc:	f108 00a8 	add.w	r0, r8, #168	; 0xa8
  e0:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1736
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  e4:	f108 00bc 	add.w	r0, r8, #188	; 0xbc
  e8:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1742
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  ec:	9b01      	ldr	r3, [sp, #4]
  ee:	f8c8 30d0 	str.w	r3, [r8, #208]	; 0xd0
C:\cortex\dimmers\rtos\src/tasks.c:1743
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  f2:	f8c8 90d4 	str.w	r9, [r8, #212]	; 0xd4
  f6:	e007      	b.n	108 <xTaskCreate+0x108>
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:418
			else
			{	
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  f8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
  fc:	b923      	cbnz	r3, 108 <xTaskCreate+0x108>
C:\cortex\dimmers\rtos\src/tasks.c:420
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  fe:	6863      	ldr	r3, [r4, #4]
 100:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 102:	42bb      	cmp	r3, r7
C:\cortex\dimmers\rtos\src/tasks.c:422
					{
						pxCurrentTCB = pxNewTCB;	
 104:	bf98      	it	ls
 106:	6066      	strls	r6, [r4, #4]
C:\cortex\dimmers\rtos\src/tasks.c:429
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 108:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 10a:	f8d4 20dc 	ldr.w	r2, [r4, #220]	; 0xdc
C:\cortex\dimmers\rtos\src/tasks.c:442
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
 10e:	4629      	mov	r1, r5
C:\cortex\dimmers\rtos\src/tasks.c:429
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 110:	4293      	cmp	r3, r2
C:\cortex\dimmers\rtos\src/tasks.c:431
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 112:	bf84      	itt	hi
 114:	4a15      	ldrhi	r2, [pc, #84]	; (16c <xTaskCreate+0x16c>)
 116:	f8c2 30dc 	strhi.w	r3, [r2, #220]	; 0xdc
C:\cortex\dimmers\rtos\src/tasks.c:440
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 11a:	f8d4 20e0 	ldr.w	r2, [r4, #224]	; 0xe0
 11e:	3201      	adds	r2, #1
 120:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
C:\cortex\dimmers\rtos\src/tasks.c:442

			prvAddTaskToReadyQueue( pxNewTCB );
 124:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
 128:	4293      	cmp	r3, r2
 12a:	bf84      	itt	hi
 12c:	4a0f      	ldrhi	r2, [pc, #60]	; (16c <xTaskCreate+0x16c>)
 12e:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
 132:	2014      	movs	r0, #20
 134:	fb00 b003 	mla	r0, r0, r3, fp
 138:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:447

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 13c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:457
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 140:	f1ba 0f00 	cmp.w	sl, #0
 144:	d001      	beq.n	14a <xTaskCreate+0x14a>
C:\cortex\dimmers\rtos\src/tasks.c:462
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 146:	f8ca 6000 	str.w	r6, [sl]
C:\cortex\dimmers\rtos\src/tasks.c:465
		}

		if( xSchedulerRunning != pdFALSE )
 14a:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 14e:	b153      	cbz	r3, 166 <xTaskCreate+0x166>
C:\cortex\dimmers\rtos\src/tasks.c:469
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 150:	4b06      	ldr	r3, [pc, #24]	; (16c <xTaskCreate+0x16c>)
 152:	685b      	ldr	r3, [r3, #4]
 154:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 156:	42bb      	cmp	r3, r7
 158:	d205      	bcs.n	166 <xTaskCreate+0x166>
C:\cortex\dimmers\rtos\src/tasks.c:471
			{
				taskYIELD();
 15a:	f7ff fffe 	bl	0 <vPortYieldFromISR>
 15e:	e002      	b.n	166 <xTaskCreate+0x166>
prvAllocateTCBAndStack():
C:\cortex\dimmers\rtos\src/tasks.c:451
		}
		portEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 160:	f04f 30ff 	mov.w	r0, #4294967295
 164:	e000      	b.n	168 <xTaskCreate+0x168>
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:444
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 166:	2001      	movs	r0, #1
C:\cortex\dimmers\rtos\src/tasks.c:477
			}
		}
	}

	return xReturn;
}
 168:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 16c:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskDelete:

00000000 <vTaskDelete>:
vTaskDelete():
C:\cortex\dimmers\rtos\src/tasks.c:483
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
   0:	41f0e92d 	.word	0x41f0e92d
C:\cortex\dimmers\rtos\src/tasks.c:490

		taskENTER_CRITICAL();
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
   4:	4c17      	ldr	r4, [pc, #92]	; (64 <vTaskDelete+0x64>)
C:\cortex\dimmers\rtos\src/tasks.c:483
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
   6:	4605      	mov	r5, r0
C:\cortex\dimmers\rtos\src/tasks.c:486
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   8:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:490
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
   c:	6863      	ldr	r3, [r4, #4]
   e:	429d      	cmp	r5, r3
  10:	d000      	beq.n	14 <vTaskDelete+0x14>
C:\cortex\dimmers\rtos\src/tasks.c:496
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  12:	b915      	cbnz	r5, 1a <vTaskDelete+0x1a>
  14:	6866      	ldr	r6, [r4, #4]
  16:	2500      	movs	r5, #0
  18:	e000      	b.n	1c <vTaskDelete+0x1c>
  1a:	462e      	mov	r6, r5
C:\cortex\dimmers\rtos\src/tasks.c:504

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
  1c:	1d37      	adds	r7, r6, #4
  1e:	4638      	mov	r0, r7
  20:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:507

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
  24:	6ab3      	ldr	r3, [r6, #40]	; 0x28
  26:	b11b      	cbz	r3, 30 <vTaskDelete+0x30>
C:\cortex\dimmers\rtos\src/tasks.c:509
			{
				vListRemove( &( pxTCB->xEventListItem ) );
  28:	f106 0018 	add.w	r0, r6, #24
  2c:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:512
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  30:	480d      	ldr	r0, [pc, #52]	; (68 <vTaskDelete+0x68>)
  32:	4639      	mov	r1, r7
  34:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:517

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  38:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
  3c:	3301      	adds	r3, #1
  3e:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
C:\cortex\dimmers\rtos\src/tasks.c:521

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */			
			uxTaskNumber++;
  42:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
  46:	3301      	adds	r3, #1
  48:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
C:\cortex\dimmers\rtos\src/tasks.c:523
		}
		taskEXIT_CRITICAL();
  4c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:526

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  50:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
  54:	b123      	cbz	r3, 60 <vTaskDelete+0x60>
C:\cortex\dimmers\rtos\src/tasks.c:528
		{
			if( ( void * ) pxTaskToDelete == NULL )
  56:	b91d      	cbnz	r5, 60 <vTaskDelete+0x60>
C:\cortex\dimmers\rtos\src/tasks.c:533
			{
				taskYIELD();
			}
		}
	}
  58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:530
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( ( void * ) pxTaskToDelete == NULL )
			{
				taskYIELD();
  5c:	f7ff bffe 	b.w	0 <vPortYieldFromISR>
  60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  64:	00000000 	.word	0x00000000
  68:	000000a8 	.word	0x000000a8

Disassembly of section .text.uxTaskPriorityGet:

00000000 <uxTaskPriorityGet>:
uxTaskPriorityGet():
C:\cortex\dimmers\rtos\src/tasks.c:687
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
   0:	4604b510 	.word	0x4604b510
C:\cortex\dimmers\rtos\src/tasks.c:691
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:695
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
   8:	b90c      	cbnz	r4, e <uxTaskPriorityGet+0xe>
   a:	4b03      	ldr	r3, [pc, #12]	; (18 <uxTaskPriorityGet+0x18>)
   c:	685c      	ldr	r4, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:696
			uxReturn = pxTCB->uxPriority;
   e:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:698
		}
		taskEXIT_CRITICAL();
  10:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:701

		return uxReturn;
	}
  14:	4620      	mov	r0, r4
  16:	bd10      	pop	{r4, pc}
  18:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskPrioritySet:

00000000 <vTaskPrioritySet>:
vTaskPrioritySet():
C:\cortex\dimmers\rtos\src/tasks.c:709
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:728
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
   6:	2904      	cmp	r1, #4
   8:	bf34      	ite	cc
   a:	460e      	movcc	r6, r1
   c:	2604      	movcs	r6, #4
C:\cortex\dimmers\rtos\src/tasks.c:719
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		taskENTER_CRITICAL();
   e:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:721
		{
			if( pxTask == pxCurrentTCB )
  12:	4b1f      	ldr	r3, [pc, #124]	; (90 <vTaskPrioritySet+0x90>)
  14:	685a      	ldr	r2, [r3, #4]
  16:	4294      	cmp	r4, r2
  18:	d000      	beq.n	1c <vTaskPrioritySet+0x1c>
C:\cortex\dimmers\rtos\src/tasks.c:728
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
  1a:	b914      	cbnz	r4, 22 <vTaskPrioritySet+0x22>
  1c:	685d      	ldr	r5, [r3, #4]
  1e:	2400      	movs	r4, #0
  20:	e000      	b.n	24 <vTaskPrioritySet+0x24>
  22:	4625      	mov	r5, r4
C:\cortex\dimmers\rtos\src/tasks.c:734
			
			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
  24:	6c6b      	ldr	r3, [r5, #68]	; 0x44
C:\cortex\dimmers\rtos\src/tasks.c:742
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
  26:	42b3      	cmp	r3, r6
  28:	d02e      	beq.n	88 <vTaskPrioritySet+0x88>
C:\cortex\dimmers\rtos\src/tasks.c:746
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
  2a:	429e      	cmp	r6, r3
  2c:	d903      	bls.n	36 <vTaskPrioritySet+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:754
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
  2e:	3c00      	subs	r4, #0
  30:	bf18      	it	ne
  32:	2401      	movne	r4, #1
  34:	e003      	b.n	3e <vTaskPrioritySet+0x3e>
  36:	f1d4 0401 	rsbs	r4, r4, #1
  3a:	bf38      	it	cc
  3c:	2400      	movcc	r4, #0
C:\cortex\dimmers\rtos\src/tasks.c:770

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  3e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:776
					{
						pxTCB->uxPriority = uxNewPriority;
					}
					
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;					
  40:	646e      	str	r6, [r5, #68]	; 0x44
C:\cortex\dimmers\rtos\src/tasks.c:770

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  42:	4293      	cmp	r3, r2
C:\cortex\dimmers\rtos\src/tasks.c:772
					{
						pxTCB->uxPriority = uxNewPriority;
  44:	bf08      	it	eq
  46:	62ee      	streq	r6, [r5, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:784
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
  48:	f1c6 0605 	rsb	r6, r6, #5
  4c:	61ae      	str	r6, [r5, #24]
C:\cortex\dimmers\rtos\src/tasks.c:790

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4e:	4e10      	ldr	r6, [pc, #64]	; (90 <vTaskPrioritySet+0x90>)
  50:	2214      	movs	r2, #20
  52:	f106 0808 	add.w	r8, r6, #8
  56:	fb02 8303 	mla	r3, r2, r3, r8
  5a:	696a      	ldr	r2, [r5, #20]
  5c:	429a      	cmp	r2, r3
  5e:	d110      	bne.n	82 <vTaskPrioritySet+0x82>
C:\cortex\dimmers\rtos\src/tasks.c:795
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
  60:	1d2f      	adds	r7, r5, #4
  62:	4638      	mov	r0, r7
  64:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:796
					prvAddTaskToReadyQueue( pxTCB );
  68:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  6a:	f8d6 20e4 	ldr.w	r2, [r6, #228]	; 0xe4
  6e:	4639      	mov	r1, r7
  70:	4293      	cmp	r3, r2
  72:	bf88      	it	hi
  74:	f8c6 30e4 	strhi.w	r3, [r6, #228]	; 0xe4
  78:	2014      	movs	r0, #20
  7a:	fb00 8003 	mla	r0, r0, r3, r8
  7e:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:799
				}			
				
				if( xYieldRequired == pdTRUE )
  82:	b10c      	cbz	r4, 6 <vPortYieldFromISR+0x6>
C:\cortex\dimmers\rtos\src/tasks.c:801
				{
					taskYIELD();
  84:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:806
				}				
			}
		}
		taskEXIT_CRITICAL();
	}
  88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:805
				{
					taskYIELD();
				}				
			}
		}
		taskEXIT_CRITICAL();
  8c:	f7ff bffe 	b.w	0 <vPortExitCritical>
  90:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskSuspend:

00000000 <vTaskSuspend>:
vTaskSuspend():
C:\cortex\dimmers\rtos\src/tasks.c:814
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
   0:	4604b570 	.word	0x4604b570
C:\cortex\dimmers\rtos\src/tasks.c:817
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:821
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
   8:	4b0f      	ldr	r3, [pc, #60]	; (48 <vTaskSuspend+0x48>)
   a:	685a      	ldr	r2, [r3, #4]
   c:	4294      	cmp	r4, r2
   e:	d000      	beq.n	12 <vTaskSuspend+0x12>
C:\cortex\dimmers\rtos\src/tasks.c:827
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
  10:	b914      	cbnz	r4, 18 <vTaskSuspend+0x18>
  12:	685d      	ldr	r5, [r3, #4]
  14:	2400      	movs	r4, #0
  16:	e000      	b.n	1a <vTaskSuspend+0x1a>
  18:	4625      	mov	r5, r4
C:\cortex\dimmers\rtos\src/tasks.c:832

			traceTASK_SUSPEND( pxTaskToSuspend );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
  1a:	1d2e      	adds	r6, r5, #4
  1c:	4630      	mov	r0, r6
  1e:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:835

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
  22:	6aab      	ldr	r3, [r5, #40]	; 0x28
  24:	b11b      	cbz	r3, 2e <vTaskSuspend+0x2e>
C:\cortex\dimmers\rtos\src/tasks.c:837
			{
				vListRemove( &( pxTCB->xEventListItem ) );
  26:	f105 0018 	add.w	r0, r5, #24
  2a:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:840
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  2e:	4807      	ldr	r0, [pc, #28]	; (4c <vTaskSuspend+0x4c>)
  30:	4631      	mov	r1, r6
  32:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:842
		}
		taskEXIT_CRITICAL();
  36:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:845

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
  3a:	b91c      	cbnz	r4, 44 <vTaskSuspend+0x44>
C:\cortex\dimmers\rtos\src/tasks.c:849
		{
			taskYIELD();
		}
	}
  3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:847
		taskEXIT_CRITICAL();

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
		{
			taskYIELD();
  40:	f7ff bffe 	b.w	0 <vPortYieldFromISR>
  44:	bd70      	pop	{r4, r5, r6, pc}
  46:	bf00      	nop
  48:	00000000 	.word	0x00000000
  4c:	000000bc 	.word	0x000000bc

Disassembly of section .text.xTaskIsTaskSuspended:

00000000 <xTaskIsTaskSuspended>:
xTaskIsTaskSuspended():
C:\cortex\dimmers\rtos\src/tasks.c:863
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   0:	4a086943 	.word	0x4a086943
   4:	4293      	cmp	r3, r2
   6:	d108      	bne.n	1a <xTaskIsTaskSuspended+0x1a>
C:\cortex\dimmers\rtos\src/tasks.c:866
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
   8:	6a80      	ldr	r0, [r0, #40]	; 0x28
   a:	3b28      	subs	r3, #40	; 0x28
   c:	4298      	cmp	r0, r3
   e:	d006      	beq.n	1e <xTaskIsTaskSuspended+0x1e>
C:\cortex\dimmers\rtos\src/tasks.c:858

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
  10:	f1d0 0001 	rsbs	r0, r0, #1
  14:	bf38      	it	cc
  16:	2000      	movcc	r0, #0
  18:	4770      	bx	lr
  1a:	2000      	movs	r0, #0
  1c:	4770      	bx	lr
  1e:	2000      	movs	r0, #0
C:\cortex\dimmers\rtos\src/tasks.c:880
				}
			}
		}

		return xReturn;
	}
  20:	4770      	bx	lr
  22:	bf00      	nop
  24:	000000bc 	.word	0x000000bc

Disassembly of section .text.vTaskResume:

00000000 <vTaskResume>:
vTaskResume():
C:\cortex\dimmers\rtos\src/tasks.c:888
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:897
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	d027      	beq.n	58 <vTaskResume+0x58>
   8:	4d14      	ldr	r5, [pc, #80]	; (5c <vTaskResume+0x5c>)
   a:	686b      	ldr	r3, [r5, #4]
   c:	4298      	cmp	r0, r3
   e:	d023      	beq.n	58 <vTaskResume+0x58>
C:\cortex\dimmers\rtos\src/tasks.c:899
		{
			taskENTER_CRITICAL();
  10:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:901
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
  14:	4620      	mov	r0, r4
  16:	f7ff fffe 	bl	0 <vTaskResume>
  1a:	2801      	cmp	r0, #1
  1c:	d118      	bne.n	50 <vTaskResume+0x50>
C:\cortex\dimmers\rtos\src/tasks.c:907
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
  1e:	1d26      	adds	r6, r4, #4
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:908
					prvAddTaskToReadyQueue( pxTCB );
  26:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  28:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
  2c:	4631      	mov	r1, r6
  2e:	4293      	cmp	r3, r2
  30:	4a0b      	ldr	r2, [pc, #44]	; (60 <vTaskResume+0x60>)
  32:	bf88      	it	hi
  34:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
  38:	2014      	movs	r0, #20
  3a:	fb00 2003 	mla	r0, r0, r3, r2
  3e:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:911

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  42:	686b      	ldr	r3, [r5, #4]
  44:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  48:	429a      	cmp	r2, r3
  4a:	d301      	bcc.n	50 <vTaskResume+0x50>
C:\cortex\dimmers\rtos\src/tasks.c:915
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						taskYIELD();
  4c:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:921
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
  50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:919
						will leave the lists in the correct state for the next yield. */
						taskYIELD();
					}
				}
			}
			taskEXIT_CRITICAL();
  54:	f7ff bffe 	b.w	0 <vPortExitCritical>
  58:	bd70      	pop	{r4, r5, r6, pc}
  5a:	bf00      	nop
  5c:	00000000 	.word	0x00000000
  60:	00000008 	.word	0x00000008

Disassembly of section .text.xTaskResumeFromISR:

00000000 <xTaskResumeFromISR>:
xTaskResumeFromISR():
C:\cortex\dimmers\rtos\src/tasks.c:930
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4606      	mov	r6, r0
C:\cortex\dimmers\rtos\src/tasks.c:936
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   4:	f7ff fffe 	bl	0 <xTaskResumeFromISR>
   8:	2801      	cmp	r0, #1
   a:	d123      	bne.n	54 <xTaskResumeFromISR+0x54>
C:\cortex\dimmers\rtos\src/tasks.c:940
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   c:	4d13      	ldr	r5, [pc, #76]	; (5c <xTaskResumeFromISR+0x5c>)
   e:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
  12:	b9cb      	cbnz	r3, 48 <xTaskResumeFromISR+0x48>
C:\cortex\dimmers\rtos\src/tasks.c:942
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
  14:	686b      	ldr	r3, [r5, #4]
  16:	6af4      	ldr	r4, [r6, #44]	; 0x2c
  18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1a:	429c      	cmp	r4, r3
  1c:	bf34      	ite	cc
  1e:	2400      	movcc	r4, #0
  20:	2401      	movcs	r4, #1
C:\cortex\dimmers\rtos\src/tasks.c:943
				vListRemove(  &( pxTCB->xGenericListItem ) );	
  22:	1d37      	adds	r7, r6, #4
  24:	4638      	mov	r0, r7
  26:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:944
				prvAddTaskToReadyQueue( pxTCB );
  2a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  2c:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
  30:	4639      	mov	r1, r7
  32:	4293      	cmp	r3, r2
  34:	4a0a      	ldr	r2, [pc, #40]	; (60 <xTaskResumeFromISR+0x60>)
  36:	bf88      	it	hi
  38:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
  3c:	2014      	movs	r0, #20
  3e:	fb00 2003 	mla	r0, r0, r3, r2
  42:	f7ff fffe 	bl	0 <vListInsertEnd>
  46:	e006      	b.n	56 <xTaskResumeFromISR+0x56>
C:\cortex\dimmers\rtos\src/tasks.c:951
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  48:	f105 0094 	add.w	r0, r5, #148	; 0x94
  4c:	f106 0118 	add.w	r1, r6, #24
  50:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:931

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
  54:	2400      	movs	r4, #0
C:\cortex\dimmers\rtos\src/tasks.c:956
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
			}
		}

		return xYieldRequired;
	}
  56:	4620      	mov	r0, r4
  58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  5a:	bf00      	nop
  5c:	00000000 	.word	0x00000000
  60:	00000008 	.word	0x00000008

Disassembly of section .text.vTaskStartScheduler:

00000000 <vTaskStartScheduler>:
vTaskStartScheduler():
C:\cortex\dimmers\rtos\src/tasks.c:969
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
   0:	2400b513 	.word	0x2400b513
C:\cortex\dimmers\rtos\src/tasks.c:973
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
   4:	2280      	movs	r2, #128	; 0x80
   6:	4623      	mov	r3, r4
   8:	480c      	ldr	r0, [pc, #48]	; (3c <vTaskStartScheduler+0x3c>)
   a:	490d      	ldr	r1, [pc, #52]	; (40 <vTaskStartScheduler+0x40>)
   c:	9400      	str	r4, [sp, #0]
   e:	9401      	str	r4, [sp, #4]
  10:	f7ff fffe 	bl	0 <vTaskStartScheduler>
C:\cortex\dimmers\rtos\src/tasks.c:975

	if( xReturn == pdPASS )
  14:	2801      	cmp	r0, #1
C:\cortex\dimmers\rtos\src/tasks.c:973
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
  16:	4603      	mov	r3, r0
C:\cortex\dimmers\rtos\src/tasks.c:975

	if( xReturn == pdPASS )
  18:	d10d      	bne.n	36 <vTaskStartScheduler+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:985
		so interrupts will automatically get re-enabled when the first task
		starts to run.
		
		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  1a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
  1e:	f380 8811 	msr	BASEPRI, r0
C:\cortex\dimmers\rtos\src/tasks.c:987

		xSchedulerRunning = pdTRUE;
  22:	4a08      	ldr	r2, [pc, #32]	; (44 <vTaskStartScheduler+0x44>)
  24:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
C:\cortex\dimmers\rtos\src/tasks.c:988
		xTickCount = ( portTickType ) 0;
  28:	f8c2 40f0 	str.w	r4, [r2, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:1002
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
  2c:	b002      	add	sp, #8
  2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:992
		xSchedulerRunning = pdTRUE;
		xTickCount = ( portTickType ) 0;

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
  32:	f7ff bffe 	b.w	0 <xPortStartScheduler>
C:\cortex\dimmers\rtos\src/tasks.c:1002
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
  36:	b002      	add	sp, #8
  38:	bd10      	pop	{r4, pc}
  3a:	bf00      	nop
	...

Disassembly of section .text.vTaskEndScheduler:

00000000 <vTaskEndScheduler>:
vTaskEndScheduler():
C:\cortex\dimmers\rtos\src/tasks.c:1010
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
   0:	f04f 00bf 	mov.w	r0, #191	; 0xbf
   4:	f380 8811 	msr	BASEPRI, r0
C:\cortex\dimmers\rtos\src/tasks.c:1011
	xSchedulerRunning = pdFALSE;
   8:	4b02      	ldr	r3, [pc, #8]	; (14 <vTaskEndScheduler+0x14>)
   a:	2200      	movs	r2, #0
   c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
C:\cortex\dimmers\rtos\src/tasks.c:1012
	vPortEndScheduler();
  10:	f7ff bffe 	b.w	0 <vPortEndScheduler>
  14:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskSuspendAll:

00000000 <vTaskSuspendAll>:
vTaskSuspendAll():
C:\cortex\dimmers\rtos\src/tasks.c:1020

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
   0:	f8d34b03 	.word	0xf8d34b03
   4:	20ec      	movs	r0, #236	; 0xec
   6:	3201      	adds	r2, #1
   8:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
C:\cortex\dimmers\rtos\src/tasks.c:1021
}
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	00000000 	.word	0x00000000

Disassembly of section .text.xTaskGetTickCount:

00000000 <xTaskGetTickCount>:
xTaskGetTickCount():
C:\cortex\dimmers\rtos\src/tasks.c:1107
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
   0:	b510      	push	{r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1111
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   2:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1113
	{
		xTicks = xTickCount;
   6:	4b03      	ldr	r3, [pc, #12]	; (14 <xTaskGetTickCount+0x14>)
   8:	f8d3 40f0 	ldr.w	r4, [r3, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:1115
	}
	taskEXIT_CRITICAL();
   c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1118

	return xTicks;
}
  10:	4620      	mov	r0, r4
  12:	bd10      	pop	{r4, pc}
  14:	00000000 	.word	0x00000000

Disassembly of section .text.uxTaskGetNumberOfTasks:

00000000 <uxTaskGetNumberOfTasks>:
uxTaskGetNumberOfTasks():
C:\cortex\dimmers\rtos\src/tasks.c:1125

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
   0:	68184b01 	.word	0x68184b01
C:\cortex\dimmers\rtos\src/tasks.c:1126
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskIncrementTick:

00000000 <vTaskIncrementTick>:
vTaskIncrementTick():
C:\cortex\dimmers\rtos\src/tasks.c:1231
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   0:	4b26      	ldr	r3, [pc, #152]	; (9c <vTaskIncrementTick+0x9c>)
C:\cortex\dimmers\rtos\src/tasks.c:1227
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
   2:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1231
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   4:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
   8:	461c      	mov	r4, r3
   a:	2a00      	cmp	r2, #0
   c:	d13f      	bne.n	8e <vTaskIncrementTick+0x8e>
C:\cortex\dimmers\rtos\src/tasks.c:1233
	{
		++xTickCount;
   e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
  12:	3301      	adds	r3, #1
  14:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:1234
		if( xTickCount == ( portTickType ) 0 )
  18:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
  1c:	bb5b      	cbnz	r3, 76 <vTaskIncrementTick+0x76>
C:\cortex\dimmers\rtos\src/tasks.c:1241
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
  1e:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
C:\cortex\dimmers\rtos\src/tasks.c:1242
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  22:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
  26:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0
C:\cortex\dimmers\rtos\src/tasks.c:1243
			pxOverflowDelayedTaskList = pxTemp;
  2a:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
C:\cortex\dimmers\rtos\src/tasks.c:1244
            xNumOfOverflows++;
  2e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
  32:	3301      	adds	r3, #1
  34:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
  38:	e01d      	b.n	76 <vTaskIncrementTick+0x76>
C:\cortex\dimmers\rtos\src/tasks.c:1248
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  3a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
  3e:	686b      	ldr	r3, [r5, #4]
  40:	429a      	cmp	r2, r3
  42:	d329      	bcc.n	98 <vTaskIncrementTick+0x98>
  44:	1d2e      	adds	r6, r5, #4
  46:	4630      	mov	r0, r6
  48:	f7ff fffe 	bl	0 <vListRemove>
  4c:	6aab      	ldr	r3, [r5, #40]	; 0x28
  4e:	b11b      	cbz	r3, 58 <vTaskIncrementTick+0x58>
  50:	f105 0018 	add.w	r0, r5, #24
  54:	f7ff fffe 	bl	0 <vListRemove>
  58:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
  5c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  5e:	4631      	mov	r1, r6
  60:	4293      	cmp	r3, r2
  62:	bf84      	itt	hi
  64:	4a0d      	ldrhi	r2, [pc, #52]	; (9c <vTaskIncrementTick+0x9c>)
  66:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
  6a:	4a0d      	ldr	r2, [pc, #52]	; (a0 <vTaskIncrementTick+0xa0>)
  6c:	2014      	movs	r0, #20
  6e:	fb00 2003 	mla	r0, r0, r3, r2
  72:	f7ff fffe 	bl	0 <vListInsertEnd>
  76:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
  7a:	4b08      	ldr	r3, [pc, #32]	; (9c <vTaskIncrementTick+0x9c>)
  7c:	6812      	ldr	r2, [r2, #0]
  7e:	b15a      	cbz	r2, 98 <vTaskIncrementTick+0x98>
  80:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
  84:	68d2      	ldr	r2, [r2, #12]
  86:	68d5      	ldr	r5, [r2, #12]
  88:	2d00      	cmp	r5, #0
  8a:	d1d6      	bne.n	3a <vTaskIncrementTick+0x3a>
  8c:	bd70      	pop	{r4, r5, r6, pc}
C:\cortex\dimmers\rtos\src/tasks.c:1252
	}
	else
	{
		++uxMissedTicks;
  8e:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
  92:	3201      	adds	r2, #1
  94:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
  98:	bd70      	pop	{r4, r5, r6, pc}
  9a:	bf00      	nop
  9c:	00000000 	.word	0x00000000
  a0:	00000008 	.word	0x00000008

Disassembly of section .text.xTaskResumeAll:

00000000 <xTaskResumeAll>:
xTaskResumeAll():
C:\cortex\dimmers\rtos\src/tasks.c:1025
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1036
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
	{
		--uxSchedulerSuspended;
   4:	4c2d      	ldr	r4, [pc, #180]	; (b8 <vPortEnterCritical+0xb8>)
C:\cortex\dimmers\rtos\src/tasks.c:1034
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
   6:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1036
	{
		--uxSchedulerSuspended;
   a:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
   e:	3b01      	subs	r3, #1
  10:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
C:\cortex\dimmers\rtos\src/tasks.c:1038

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  14:	f8d4 60ec 	ldr.w	r6, [r4, #236]	; 0xec
  18:	2e00      	cmp	r6, #0
  1a:	d147      	bne.n	ac <xTaskResumeAll+0xac>
C:\cortex\dimmers\rtos\src/tasks.c:1040
		{			
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  1c:	6823      	ldr	r3, [r4, #0]
  1e:	b9eb      	cbnz	r3, 5c <xTaskResumeAll+0x5c>
  20:	e046      	b.n	b0 <xTaskResumeAll+0xb0>
C:\cortex\dimmers\rtos\src/tasks.c:1048
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
  22:	f105 0018 	add.w	r0, r5, #24
C:\cortex\dimmers\rtos\src/tasks.c:1049
					vListRemove( &( pxTCB->xGenericListItem ) );
  26:	f105 0804 	add.w	r8, r5, #4
C:\cortex\dimmers\rtos\src/tasks.c:1048
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
  2a:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1049
					vListRemove( &( pxTCB->xGenericListItem ) );
  2e:	4640      	mov	r0, r8
  30:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1050
					prvAddTaskToReadyQueue( pxTCB );
  34:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  36:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
  3a:	4641      	mov	r1, r8
  3c:	4293      	cmp	r3, r2
  3e:	4a20      	ldr	r2, [pc, #128]	; (c0 <xTaskResumeAll+0xc0>)
  40:	bf88      	it	hi
  42:	f8c7 30e4 	strhi.w	r3, [r7, #228]	; 0xe4
  46:	2014      	movs	r0, #20
  48:	fb00 2003 	mla	r0, r0, r3, r2
  4c:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1054
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  50:	6863      	ldr	r3, [r4, #4]
  52:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1056
					{
						xYieldRequired = pdTRUE;
  56:	429a      	cmp	r2, r3
  58:	bf28      	it	cs
  5a:	2601      	movcs	r6, #1
C:\cortex\dimmers\rtos\src/tasks.c:1046
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
  5c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
  60:	4f16      	ldr	r7, [pc, #88]	; (bc <xTaskResumeAll+0xbc>)
  62:	b123      	cbz	r3, 6e <xTaskResumeAll+0x6e>
  64:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  68:	68dd      	ldr	r5, [r3, #12]
  6a:	2d00      	cmp	r5, #0
  6c:	d1d9      	bne.n	22 <xTaskResumeAll+0x22>
C:\cortex\dimmers\rtos\src/tasks.c:1063
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  6e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
  72:	b93b      	cbnz	r3, 84 <xTaskResumeAll+0x84>
  74:	e00c      	b.n	90 <xTaskResumeAll+0x90>
C:\cortex\dimmers\rtos\src/tasks.c:1067
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
  76:	f7ff fffe 	bl	0 <xTaskResumeAll>
C:\cortex\dimmers\rtos\src/tasks.c:1068
						--uxMissedTicks;
  7a:	f8d5 30f8 	ldr.w	r3, [r5, #248]	; 0xf8
  7e:	3b01      	subs	r3, #1
  80:	f8c5 30f8 	str.w	r3, [r5, #248]	; 0xf8
C:\cortex\dimmers\rtos\src/tasks.c:1065
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  84:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
  88:	4d0c      	ldr	r5, [pc, #48]	; (bc <xTaskResumeAll+0xbc>)
  8a:	2b00      	cmp	r3, #0
  8c:	d1f3      	bne.n	76 <xTaskResumeAll+0x76>
  8e:	e006      	b.n	9e <xTaskResumeAll+0x9e>
C:\cortex\dimmers\rtos\src/tasks.c:1081
						xYieldRequired = pdTRUE;
					}
					#endif
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  90:	2e01      	cmp	r6, #1
  92:	d004      	beq.n	9e <xTaskResumeAll+0x9e>
  94:	4a09      	ldr	r2, [pc, #36]	; (bc <xTaskResumeAll+0xbc>)
  96:	f8d2 20fc 	ldr.w	r2, [r2, #252]	; 0xfc
  9a:	2a01      	cmp	r2, #1
  9c:	d108      	bne.n	b0 <xTaskResumeAll+0xb0>
C:\cortex\dimmers\rtos\src/tasks.c:1084
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  9e:	2300      	movs	r3, #0
  a0:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
C:\cortex\dimmers\rtos\src/tasks.c:1085
					taskYIELD();
  a4:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:1083
					#endif
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  a8:	2401      	movs	r4, #1
  aa:	e002      	b.n	b2 <xTaskResumeAll+0xb2>
C:\cortex\dimmers\rtos\src/tasks.c:1027
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  ac:	2400      	movs	r4, #0
  ae:	e000      	b.n	b2 <xTaskResumeAll+0xb2>
  b0:	461c      	mov	r4, r3
C:\cortex\dimmers\rtos\src/tasks.c:1090
					taskYIELD();
				}
			}
		}
	}
	portEXIT_CRITICAL();
  b2:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1093

	return xAlreadyYielded;
}
  b6:	4620      	mov	r0, r4
  b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  bc:	00000000 	.word	0x00000000
  c0:	00000008 	.word	0x00000008

Disassembly of section .text.prvIdleTask:

00000000 <prvIdleTask>:
prvIdleTask():
C:\cortex\dimmers\rtos\src/tasks.c:1607
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   0:	4c16b538 	.word	0x4c16b538
prvCheckTasksWaitingTermination():
C:\cortex\dimmers\rtos\src/tasks.c:1755
	{				
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
   4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   8:	b30b      	cbz	r3, 46 <prvIdleTask+0x46>
C:\cortex\dimmers\rtos\src/tasks.c:1757
		{
			vTaskSuspendAll();
   a:	f7ff fffe 	bl	0 <prvIdleTask>
C:\cortex\dimmers\rtos\src/tasks.c:1758
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );				
   e:	f8d4 50a8 	ldr.w	r5, [r4, #168]	; 0xa8
C:\cortex\dimmers\rtos\src/tasks.c:1759
			xTaskResumeAll();
  12:	f7ff fffe 	bl	0 <prvIdleTask>
C:\cortex\dimmers\rtos\src/tasks.c:1761

			if( !xListIsEmpty )
  16:	b1d5      	cbz	r5, 38 <vPortEnterCritical+0x38>
C:\cortex\dimmers\rtos\src/tasks.c:1765
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
  18:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1767
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  1c:	f8d4 50a8 	ldr.w	r5, [r4, #168]	; 0xa8
  20:	b115      	cbz	r5, 28 <prvIdleTask+0x28>
  22:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
  26:	68dd      	ldr	r5, [r3, #12]
C:\cortex\dimmers\rtos\src/tasks.c:1768
					vListRemove( &( pxTCB->xGenericListItem ) );
  28:	1d28      	adds	r0, r5, #4
  2a:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1769
					--uxCurrentNumberOfTasks;
  2e:	6823      	ldr	r3, [r4, #0]
  30:	3b01      	subs	r3, #1
  32:	6023      	str	r3, [r4, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1770
					--uxTasksDeleted;
  34:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
  38:	3b01      	subs	r3, #1
  3a:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
C:\cortex\dimmers\rtos\src/tasks.c:1772
				}
				portEXIT_CRITICAL();
  3e:	f7ff fffe 	bl	0 <vPortExitCritical>
prvDeleteTCB():
C:\cortex\dimmers\rtos\src/tasks.c:1887

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFree( pxTCB->pxStack );
  42:	6b28      	ldr	r0, [r5, #48]	; 0x30
  44:	f7ff fffe 	bl	0 <vPortFree>
C:\cortex\dimmers\rtos\src/tasks.c:1888
		vPortFree( pxTCB );
  48:	4628      	mov	r0, r5
  4a:	f7ff fffe 	bl	0 <vPortFree>
prvIdleTask():
C:\cortex\dimmers\rtos\src/tasks.c:1637
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4e:	68a3      	ldr	r3, [r4, #8]
  50:	2b01      	cmp	r3, #1
  52:	d9d6      	bls.n	2 <prvIdleTask+0x2>
C:\cortex\dimmers\rtos\src/tasks.c:1639
			{
				taskYIELD();
  54:	f7ff fffe 	bl	0 <vPortYieldFromISR>
  58:	e7d3      	b.n	2 <prvIdleTask+0x2>
  5a:	bf00      	nop
  5c:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskDelay:

00000000 <vTaskDelay>:
vTaskDelay():
C:\cortex\dimmers\rtos\src/tasks.c:626
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
   0:	4605b570 	.word	0x4605b570
C:\cortex\dimmers\rtos\src/tasks.c:631
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
   4:	b1d0      	cbz	r0, 3c <vTaskDelay+0x3c>
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   6:	4c10      	ldr	r4, [pc, #64]	; (48 <vTaskDelay+0x48>)
C:\cortex\dimmers\rtos\src/tasks.c:633
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
   8:	f7ff fffe 	bl	0 <vTaskDelay>
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:652

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  10:	6860      	ldr	r0, [r4, #4]
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  12:	18ed      	adds	r5, r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:652

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  14:	3004      	adds	r0, #4
  16:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:655

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  1a:	6863      	ldr	r3, [r4, #4]
  1c:	605d      	str	r5, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:657

				if( xTimeToWake < xTickCount )
  1e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
  22:	429d      	cmp	r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:661
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  24:	bf34      	ite	cc
  26:	f8d4 00d4 	ldrcc.w	r0, [r4, #212]	; 0xd4
C:\cortex\dimmers\rtos\src/tasks.c:667
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  2a:	f8d4 00d0 	ldrcs.w	r0, [r4, #208]	; 0xd0
  2e:	6861      	ldr	r1, [r4, #4]
  30:	3104      	adds	r1, #4
  32:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:670
				}
			}
			xAlreadyYielded = xTaskResumeAll();
  36:	f7ff fffe 	bl	0 <vTaskDelay>
C:\cortex\dimmers\rtos\src/tasks.c:675
		}
		
		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
  3a:	b918      	cbnz	r0, 44 <vTaskDelay+0x44>
C:\cortex\dimmers\rtos\src/tasks.c:679
		{
			taskYIELD();
		}
	}
  3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:677
		
		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
		{
			taskYIELD();
  40:	f7ff bffe 	b.w	0 <vPortYieldFromISR>
  44:	bd70      	pop	{r4, r5, r6, pc}
  46:	bf00      	nop
  48:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskDelayUntil:

00000000 <vTaskDelayUntil>:
vTaskDelayUntil():
C:\cortex\dimmers\rtos\src/tasks.c:549
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:558
		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
   2:	4d1b      	ldr	r5, [pc, #108]	; (70 <vTaskDelayUntil+0x70>)
C:\cortex\dimmers\rtos\src/tasks.c:549
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
   4:	4606      	mov	r6, r0
   6:	460c      	mov	r4, r1
C:\cortex\dimmers\rtos\src/tasks.c:553
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
   8:	f7ff fffe 	bl	0 <vTaskDelayUntil>
C:\cortex\dimmers\rtos\src/tasks.c:556
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   c:	6833      	ldr	r3, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:558

			if( xTickCount < *pxPreviousWakeTime )
   e:	f8d5 20f0 	ldr.w	r2, [r5, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:556
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  12:	18e4      	adds	r4, r4, r3
C:\cortex\dimmers\rtos\src/tasks.c:558

			if( xTickCount < *pxPreviousWakeTime )
  14:	429a      	cmp	r2, r3
  16:	d202      	bcs.n	1e <vTaskDelayUntil+0x1e>
C:\cortex\dimmers\rtos\src/tasks.c:565
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
  18:	429c      	cmp	r4, r3
  1a:	d209      	bcs.n	30 <vTaskDelayUntil+0x30>
  1c:	e001      	b.n	22 <vTaskDelayUntil+0x22>
C:\cortex\dimmers\rtos\src/tasks.c:575
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
  1e:	429c      	cmp	r4, r3
  20:	d308      	bcc.n	34 <vTaskDelayUntil+0x34>
  22:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:551
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
  26:	429c      	cmp	r4, r3
  28:	bf94      	ite	ls
  2a:	2300      	movls	r3, #0
  2c:	2301      	movhi	r3, #1
  2e:	e002      	b.n	36 <vTaskDelayUntil+0x36>
  30:	2300      	movs	r3, #0
  32:	e000      	b.n	36 <vTaskDelayUntil+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:577
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
  34:	2301      	movs	r3, #1
C:\cortex\dimmers\rtos\src/tasks.c:582
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  36:	6034      	str	r4, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:584

			if( xShouldDelay )
  38:	b193      	cbz	r3, 60 <vTaskDelayUntil+0x60>
C:\cortex\dimmers\rtos\src/tasks.c:591
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  3a:	6868      	ldr	r0, [r5, #4]
  3c:	4e0c      	ldr	r6, [pc, #48]	; (70 <vTaskDelayUntil+0x70>)
  3e:	3004      	adds	r0, #4
  40:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:594

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  44:	686b      	ldr	r3, [r5, #4]
  46:	605c      	str	r4, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:596

				if( xTimeToWake < xTickCount )
  48:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
  4c:	429c      	cmp	r4, r3
C:\cortex\dimmers\rtos\src/tasks.c:600
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4e:	bf34      	ite	cc
  50:	f8d6 00d4 	ldrcc.w	r0, [r6, #212]	; 0xd4
C:\cortex\dimmers\rtos\src/tasks.c:606
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  54:	f8d6 00d0 	ldrcs.w	r0, [r6, #208]	; 0xd0
  58:	6871      	ldr	r1, [r6, #4]
  5a:	3104      	adds	r1, #4
  5c:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:610
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  60:	f7ff fffe 	bl	0 <vTaskDelayUntil>
C:\cortex\dimmers\rtos\src/tasks.c:614

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
  64:	b918      	cbnz	r0, 6e <vTaskDelayUntil+0x6e>
C:\cortex\dimmers\rtos\src/tasks.c:618
		{
			taskYIELD();
		}
	}	
  66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:616

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
		{
			taskYIELD();
  6a:	f7ff bffe 	b.w	0 <vPortYieldFromISR>
  6e:	bd70      	pop	{r4, r5, r6, pc}
  70:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskSwitchContext:

00000000 <vTaskSwitchContext>:
vTaskSwitchContext():
C:\cortex\dimmers\rtos\src/tasks.c:1397

void vTaskSwitchContext( void )
{
	traceTASK_SWITCHED_OUT();

	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   0:	b5304b15 	.word	0xb5304b15
   4:	f8d3 10ec 	ldr.w	r1, [r3, #236]	; 0xec
   8:	461a      	mov	r2, r3
   a:	b141      	cbz	r1, 1e <vTaskSwitchContext+0x1e>
C:\cortex\dimmers\rtos\src/tasks.c:1401
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
   c:	2201      	movs	r2, #1
   e:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
C:\cortex\dimmers\rtos\src/tasks.c:1402
		return;
  12:	bd30      	pop	{r4, r5, pc}
C:\cortex\dimmers\rtos\src/tasks.c:1411
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
  14:	f8d3 10e4 	ldr.w	r1, [r3, #228]	; 0xe4
  18:	3901      	subs	r1, #1
  1a:	f8c3 10e4 	str.w	r1, [r3, #228]	; 0xe4
C:\cortex\dimmers\rtos\src/tasks.c:1409

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  1e:	f8d2 10e4 	ldr.w	r1, [r2, #228]	; 0xe4
  22:	2514      	movs	r5, #20
  24:	fb05 2101 	mla	r1, r5, r1, r2
  28:	6889      	ldr	r1, [r1, #8]
  2a:	4b0b      	ldr	r3, [pc, #44]	; (58 <vTaskSwitchContext+0x58>)
  2c:	2900      	cmp	r1, #0
  2e:	d0f1      	beq.n	14 <vTaskSwitchContext+0x14>
C:\cortex\dimmers\rtos\src/tasks.c:1416
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  30:	f8d3 40e4 	ldr.w	r4, [r3, #228]	; 0xe4
  34:	4365      	muls	r5, r4
  36:	1959      	adds	r1, r3, r5
  38:	68c8      	ldr	r0, [r1, #12]
  3a:	460b      	mov	r3, r1
  3c:	6840      	ldr	r0, [r0, #4]
  3e:	3310      	adds	r3, #16
  40:	60c8      	str	r0, [r1, #12]
  42:	4298      	cmp	r0, r3
  44:	bf04      	itt	eq
  46:	6843      	ldreq	r3, [r0, #4]
  48:	60cb      	streq	r3, [r1, #12]
  4a:	2314      	movs	r3, #20
  4c:	fb03 2404 	mla	r4, r3, r4, r2
  50:	68e3      	ldr	r3, [r4, #12]
  52:	68db      	ldr	r3, [r3, #12]
  54:	6053      	str	r3, [r2, #4]
  56:	bd30      	pop	{r4, r5, pc}
  58:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskPlaceOnEventList:

00000000 <vTaskPlaceOnEventList>:
vTaskPlaceOnEventList():
C:\cortex\dimmers\rtos\src/tasks.c:1424
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   0:	4c14b570 	.word	0x4c14b570
   4:	460d      	mov	r5, r1
C:\cortex\dimmers\rtos\src/tasks.c:1433
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   6:	6861      	ldr	r1, [r4, #4]
   8:	3118      	adds	r1, #24
   a:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:1438

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   e:	6860      	ldr	r0, [r4, #4]
  10:	3004      	adds	r0, #4
  12:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1443


	#if ( INCLUDE_vTaskSuspend == 1 )
	{			
		if( xTicksToWait == portMAX_DELAY )
  16:	f1b5 3fff 	cmp.w	r5, #4294967295
  1a:	d107      	bne.n	2c <vTaskPlaceOnEventList+0x2c>
C:\cortex\dimmers\rtos\src/tasks.c:1448
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  1c:	6861      	ldr	r1, [r4, #4]
  1e:	f104 00bc 	add.w	r0, r4, #188	; 0xbc
  22:	3104      	adds	r1, #4
C:\cortex\dimmers\rtos\src/tasks.c:1490
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
  24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1448
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  28:	f7ff bffe 	b.w	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1454
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  2c:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
  30:	18ed      	adds	r5, r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:1456
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  32:	6863      	ldr	r3, [r4, #4]
  34:	605d      	str	r5, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1458
		
			if( xTimeToWake < xTickCount )
  36:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
  3a:	429d      	cmp	r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:1461
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  3c:	bf34      	ite	cc
  3e:	f8d4 00d4 	ldrcc.w	r0, [r4, #212]	; 0xd4
C:\cortex\dimmers\rtos\src/tasks.c:1466
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  42:	f8d4 00d0 	ldrcs.w	r0, [r4, #208]	; 0xd0
  46:	6861      	ldr	r1, [r4, #4]
  48:	3104      	adds	r1, #4
C:\cortex\dimmers\rtos\src/tasks.c:1490
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
  4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1466
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4e:	f7ff bffe 	b.w	0 <vListInsert>
  52:	bf00      	nop
  54:	00000000 	.word	0x00000000

Disassembly of section .text.xTaskRemoveFromEventList:

00000000 <xTaskRemoveFromEventList>:
xTaskRemoveFromEventList():
C:\cortex\dimmers\rtos\src/tasks.c:1494
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1508
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   2:	6804      	ldr	r4, [r0, #0]
   4:	b10c      	cbz	r4, a <xTaskRemoveFromEventList+0xa>
   6:	68c3      	ldr	r3, [r0, #12]
   8:	68dc      	ldr	r4, [r3, #12]
C:\cortex\dimmers\rtos\src/tasks.c:1509
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
   a:	f104 0618 	add.w	r6, r4, #24
C:\cortex\dimmers\rtos\src/tasks.c:1511

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   e:	4d12      	ldr	r5, [pc, #72]	; (58 <xTaskRemoveFromEventList+0x58>)
C:\cortex\dimmers\rtos\src/tasks.c:1509
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  10:	4630      	mov	r0, r6
  12:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1511

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  16:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
  1a:	b97b      	cbnz	r3, 3c <xTaskRemoveFromEventList+0x3c>
C:\cortex\dimmers\rtos\src/tasks.c:1513
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  1c:	1d26      	adds	r6, r4, #4
  1e:	4630      	mov	r0, r6
  20:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1514
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  24:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  26:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
  2a:	4293      	cmp	r3, r2
  2c:	4a0b      	ldr	r2, [pc, #44]	; (5c <xTaskRemoveFromEventList+0x5c>)
  2e:	bf88      	it	hi
  30:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
  34:	2014      	movs	r0, #20
  36:	fb00 2003 	mla	r0, r0, r3, r2
  3a:	e001      	b.n	40 <xTaskRemoveFromEventList+0x40>
C:\cortex\dimmers\rtos\src/tasks.c:1520
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  3c:	f105 0094 	add.w	r0, r5, #148	; 0x94
  40:	4631      	mov	r1, r6
  42:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1523
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  46:	686b      	ldr	r3, [r5, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1529
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  48:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1537
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4c:	4298      	cmp	r0, r3
  4e:	bf34      	ite	cc
  50:	2000      	movcc	r0, #0
  52:	2001      	movcs	r0, #1
  54:	bd70      	pop	{r4, r5, r6, pc}
  56:	bf00      	nop
  58:	00000000 	.word	0x00000000
  5c:	00000008 	.word	0x00000008

Disassembly of section .text.vTaskSetTimeOutState:

00000000 <vTaskSetTimeOutState>:
vTaskSetTimeOutState():
C:\cortex\dimmers\rtos\src/tasks.c:1542
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
   0:	f8d34b03 	.word	0xf8d34b03
   4:	20f4      	movs	r0, #244	; 0xf4
C:\cortex\dimmers\rtos\src/tasks.c:1543
    pxTimeOut->xTimeOnEntering = xTickCount;
   6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
C:\cortex\dimmers\rtos\src/tasks.c:1542
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
   a:	6002      	str	r2, [r0, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1543
    pxTimeOut->xTimeOnEntering = xTickCount;
   c:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1544
}
   e:	4770      	bx	lr
  10:	00000000 	.word	0x00000000

Disassembly of section .text.xTaskCheckForTimeOut:

00000000 <xTaskCheckForTimeOut>:
xTaskCheckForTimeOut():
C:\cortex\dimmers\rtos\src/tasks.c:1548
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
   4:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:1551
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
   6:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1557
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   a:	682b      	ldr	r3, [r5, #0]
   c:	f1b3 3fff 	cmp.w	r3, #4294967295
  10:	d01a      	beq.n	48 <xTaskCheckForTimeOut+0x48>
C:\cortex\dimmers\rtos\src/tasks.c:1564
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
  12:	4a11      	ldr	r2, [pc, #68]	; (58 <xTaskCheckForTimeOut+0x58>)
  14:	6821      	ldr	r1, [r4, #0]
  16:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
  1a:	4288      	cmp	r0, r1
  1c:	4611      	mov	r1, r2
  1e:	d004      	beq.n	2a <xTaskCheckForTimeOut+0x2a>
  20:	f8d2 00f0 	ldr.w	r0, [r2, #240]	; 0xf0
  24:	6862      	ldr	r2, [r4, #4]
  26:	4290      	cmp	r0, r2
  28:	d210      	bcs.n	4c <xTaskCheckForTimeOut+0x4c>
C:\cortex\dimmers\rtos\src/tasks.c:1572
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  2a:	f8d1 10f0 	ldr.w	r1, [r1, #240]	; 0xf0
  2e:	6862      	ldr	r2, [r4, #4]
  30:	1a89      	subs	r1, r1, r2
  32:	4299      	cmp	r1, r3
  34:	d20a      	bcs.n	4c <xTaskCheckForTimeOut+0x4c>
C:\cortex\dimmers\rtos\src/tasks.c:1575
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
  36:	4908      	ldr	r1, [pc, #32]	; (58 <xTaskCheckForTimeOut+0x58>)
C:\cortex\dimmers\rtos\src/tasks.c:1576
			vTaskSetTimeOutState( pxTimeOut );
  38:	4620      	mov	r0, r4
C:\cortex\dimmers\rtos\src/tasks.c:1575
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
  3a:	f8d1 10f0 	ldr.w	r1, [r1, #240]	; 0xf0
  3e:	1a52      	subs	r2, r2, r1
  40:	18d3      	adds	r3, r2, r3
  42:	602b      	str	r3, [r5, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1576
			vTaskSetTimeOutState( pxTimeOut );
  44:	f7ff fffe 	bl	0 <xTaskCheckForTimeOut>
C:\cortex\dimmers\rtos\src/tasks.c:1559
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  48:	2400      	movs	r4, #0
  4a:	e000      	b.n	4e <xTaskCheckForTimeOut+0x4e>
C:\cortex\dimmers\rtos\src/tasks.c:1581
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
  4c:	2401      	movs	r4, #1
C:\cortex\dimmers\rtos\src/tasks.c:1584
		}
	}
	portEXIT_CRITICAL();
  4e:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1587

    return xReturn;
}
  52:	4620      	mov	r0, r4
  54:	bd38      	pop	{r3, r4, r5, pc}
  56:	bf00      	nop
  58:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskMissedYield:

00000000 <vTaskMissedYield>:
vTaskMissedYield():
C:\cortex\dimmers\rtos\src/tasks.c:1592
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
   0:	22014b02 	.word	0x22014b02
   4:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
C:\cortex\dimmers\rtos\src/tasks.c:1593
}
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	00000000 	.word	0x00000000

Disassembly of section .text.usTaskCheckFreeStackSpace:

00000000 <usTaskCheckFreeStackSpace>:
usTaskCheckFreeStackSpace():
C:\cortex\dimmers\rtos\src/tasks.c:1840

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
	register unsigned portSHORT usCount = 0;
   0:	2300      	movs	r3, #0
C:\cortex\dimmers\rtos\src/tasks.c:1842

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2:	e001      	b.n	8 <usTaskCheckFreeStackSpace+0x8>
C:\cortex\dimmers\rtos\src/tasks.c:1845
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
   4:	3301      	adds	r3, #1
   6:	b29b      	uxth	r3, r3
C:\cortex\dimmers\rtos\src/tasks.c:1842

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
	register unsigned portSHORT usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   8:	f810 2b01 	ldrb.w	r2, [r0], #1
   c:	2aa5      	cmp	r2, #165	; 0xa5
   e:	d0f9      	beq.n	4 <usTaskCheckFreeStackSpace+0x4>
C:\cortex\dimmers\rtos\src/tasks.c:1851
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
	}
  10:	0898      	lsrs	r0, r3, #2
  12:	4770      	bx	lr

Disassembly of section .text.uxTaskGetStackHighWaterMark:

00000000 <uxTaskGetStackHighWaterMark>:
uxTaskGetStackHighWaterMark():
C:\cortex\dimmers\rtos\src/tasks.c:1859
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
   0:	b508      	push	{r3, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1863
	tskTCB *pxTCB;
	unsigned portCHAR *pcEndOfStack;

		pxTCB = prvGetTCBFromHandle( xTask );
   2:	b908      	cbnz	r0, 8 <uxTaskGetStackHighWaterMark+0x8>
   4:	4b02      	ldr	r3, [pc, #8]	; (10 <uxTaskGetStackHighWaterMark+0x10>)
   6:	6858      	ldr	r0, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1875
		{
			pcEndOfStack = ( unsigned portCHAR * ) pxTCB->pxEndOfStack;
		}
		#endif

		return usTaskCheckFreeStackSpace( pcEndOfStack );
   8:	6b00      	ldr	r0, [r0, #48]	; 0x30
   a:	f7ff fffe 	bl	0 <uxTaskGetStackHighWaterMark>
C:\cortex\dimmers\rtos\src/tasks.c:1876
	}
   e:	bd08      	pop	{r3, pc}
  10:	00000000 	.word	0x00000000

Disassembly of section .text.xTaskGetCurrentTaskHandle:

00000000 <xTaskGetCurrentTaskHandle>:
xTaskGetCurrentTaskHandle():
C:\cortex\dimmers\rtos\src/tasks.c:1903
	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		return pxCurrentTCB;
   0:	68584b01 	.word	0x68584b01
C:\cortex\dimmers\rtos\src/tasks.c:1904
	}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.xTaskGetSchedulerState:

00000000 <xTaskGetSchedulerState>:
xTaskGetSchedulerState():
C:\cortex\dimmers\rtos\src/tasks.c:1916

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;
	
		if( xSchedulerRunning == pdFALSE )
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <xTaskGetSchedulerState+0x18>)
   2:	f8d3 00d8 	ldr.w	r0, [r3, #216]	; 0xd8
   6:	b128      	cbz	r0, 14 <xTaskGetSchedulerState+0x14>
C:\cortex\dimmers\rtos\src/tasks.c:1922
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   8:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
C:\cortex\dimmers\rtos\src/tasks.c:1924
			{
				xReturn = taskSCHEDULER_RUNNING;
   c:	2800      	cmp	r0, #0
   e:	bf14      	ite	ne
  10:	2002      	movne	r0, #2
  12:	2001      	moveq	r0, #1
C:\cortex\dimmers\rtos\src/tasks.c:1933
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}
		
		return xReturn;
	}
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskPriorityInherit:

00000000 <vTaskPriorityInherit>:
vTaskPriorityInherit():
C:\cortex\dimmers\rtos\src/tasks.c:1941
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )
	
	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1944
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   4:	4c16      	ldr	r4, [pc, #88]	; (60 <vTaskPriorityInherit+0x60>)
   6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   8:	6862      	ldr	r2, [r4, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1941
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )
	
	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   a:	4605      	mov	r5, r0
C:\cortex\dimmers\rtos\src/tasks.c:1944
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   e:	4293      	cmp	r3, r2
  10:	d224      	bcs.n	5c <vTaskPriorityInherit+0x5c>
C:\cortex\dimmers\rtos\src/tasks.c:1947
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  12:	6862      	ldr	r2, [r4, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1951

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  14:	f104 0708 	add.w	r7, r4, #8
C:\cortex\dimmers\rtos\src/tasks.c:1947
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  18:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  1a:	f1c2 0205 	rsb	r2, r2, #5
  1e:	6182      	str	r2, [r0, #24]
C:\cortex\dimmers\rtos\src/tasks.c:1951

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  20:	2214      	movs	r2, #20
  22:	fb02 7303 	mla	r3, r2, r3, r7
  26:	6942      	ldr	r2, [r0, #20]
  28:	429a      	cmp	r2, r3
  2a:	d114      	bne.n	56 <vTaskPriorityInherit+0x56>
C:\cortex\dimmers\rtos\src/tasks.c:1953
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  2c:	1d06      	adds	r6, r0, #4
  2e:	4630      	mov	r0, r6
  30:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1956

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  34:	6863      	ldr	r3, [r4, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1957
				prvAddTaskToReadyQueue( pxTCB );
  36:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
C:\cortex\dimmers\rtos\src/tasks.c:1956
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1957
				prvAddTaskToReadyQueue( pxTCB );
  3c:	4631      	mov	r1, r6
  3e:	4293      	cmp	r3, r2
  40:	bf88      	it	hi
  42:	f8c4 30e4 	strhi.w	r3, [r4, #228]	; 0xe4
  46:	2014      	movs	r0, #20
  48:	fb00 7003 	mla	r0, r0, r3, r7
C:\cortex\dimmers\rtos\src/tasks.c:1956
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4c:	62eb      	str	r3, [r5, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1965
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
			}
		}
	}
  4e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1957
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
				prvAddTaskToReadyQueue( pxTCB );
  52:	f7ff bffe 	b.w	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1962
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  56:	6863      	ldr	r3, [r4, #4]
  58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  5a:	62c3      	str	r3, [r0, #44]	; 0x2c
  5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  60:	00000000 	.word	0x00000000

Disassembly of section .text.vTaskPriorityDisinherit:

00000000 <vTaskPriorityDisinherit>:
vTaskPriorityDisinherit():
C:\cortex\dimmers\rtos\src/tasks.c:1973
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )	

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
   0:	4604b570 	.word	0x4604b570
C:\cortex\dimmers\rtos\src/tasks.c:1976
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
   4:	b1e0      	cbz	r0, 40 <vTaskPriorityDisinherit+0x40>
C:\cortex\dimmers\rtos\src/tasks.c:1978
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   8:	6c43      	ldr	r3, [r0, #68]	; 0x44
   a:	429a      	cmp	r2, r3
   c:	d018      	beq.n	40 <vTaskPriorityDisinherit+0x40>
C:\cortex\dimmers\rtos\src/tasks.c:1982
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
   e:	1d05      	adds	r5, r0, #4
  10:	4628      	mov	r0, r5
  12:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1986

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  16:	6c63      	ldr	r3, [r4, #68]	; 0x44
C:\cortex\dimmers\rtos\src/tasks.c:1987
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  18:	f1c3 0205 	rsb	r2, r3, #5
  1c:	61a2      	str	r2, [r4, #24]
C:\cortex\dimmers\rtos\src/tasks.c:1988
				prvAddTaskToReadyQueue( pxTCB );
  1e:	4a09      	ldr	r2, [pc, #36]	; (44 <vTaskPriorityDisinherit+0x44>)
C:\cortex\dimmers\rtos\src/tasks.c:1986
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  20:	62e3      	str	r3, [r4, #44]	; 0x2c
C:\cortex\dimmers\rtos\src/tasks.c:1988
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  22:	f8d2 10e4 	ldr.w	r1, [r2, #228]	; 0xe4
  26:	428b      	cmp	r3, r1
  28:	bf88      	it	hi
  2a:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
  2e:	4a06      	ldr	r2, [pc, #24]	; (48 <vTaskPriorityDisinherit+0x48>)
  30:	2014      	movs	r0, #20
  32:	fb00 2003 	mla	r0, r0, r3, r2
  36:	4629      	mov	r1, r5
C:\cortex\dimmers\rtos\src/tasks.c:1991
			}
		}
	}
  38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1988

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  3c:	f7ff bffe 	b.w	0 <vListInsertEnd>
  40:	bd70      	pop	{r4, r5, r6, pc}
  42:	bf00      	nop
  44:	00000000 	.word	0x00000000
  48:	00000008 	.word	0x00000008
