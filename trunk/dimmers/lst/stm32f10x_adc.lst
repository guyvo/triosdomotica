
C:\cortex\dimmers\hex\stm32f10x_adc.o:     file format elf32-littlearm
C:\cortex\dimmers\hex\stm32f10x_adc.o


Disassembly of section .text.ADC_DeInit:

00000000 <ADC_DeInit>:
ADC_DeInit():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:131
* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_DeInit(ADC_TypeDef* ADCx)
{
   0:	b507      	push	{r0, r1, r2, lr}
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:135
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  switch (*(u32*)&ADCx)
   2:	4b12      	ldr	r3, [pc, #72]	; (4c <ADC_DeInit+0x4c>)
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:131
* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_DeInit(ADC_TypeDef* ADCx)
{
   4:	9001      	str	r0, [sp, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:135
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  switch (*(u32*)&ADCx)
   6:	4298      	cmp	r0, r3
   8:	d00d      	beq.n	26 <ADC_DeInit+0x26>
   a:	4b11      	ldr	r3, [pc, #68]	; (50 <ADC_DeInit+0x50>)
   c:	4298      	cmp	r0, r3
   e:	d012      	beq.n	36 <ADC_DeInit+0x36>
  10:	4b10      	ldr	r3, [pc, #64]	; (54 <ADC_DeInit+0x54>)
  12:	4298      	cmp	r0, r3
  14:	d119      	bne.n	4a <ADC_DeInit+0x4a>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:139
  {
    case ADC1_BASE:
      /* Enable ADC1 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
  16:	f44f 7000 	mov.w	r0, #512	; 0x200
  1a:	2101      	movs	r1, #1
  1c:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:141
      /* Release ADC1 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  20:	f44f 7000 	mov.w	r0, #512	; 0x200
  24:	e00e      	b.n	44 <ADC_DeInit+0x44>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:146
      break;
    
    case ADC2_BASE:
      /* Enable ADC2 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
  26:	f44f 6080 	mov.w	r0, #1024	; 0x400
  2a:	2101      	movs	r1, #1
  2c:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:148
      /* Release ADC2 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
  30:	f44f 6080 	mov.w	r0, #1024	; 0x400
  34:	e006      	b.n	44 <ADC_DeInit+0x44>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:153
      break;
      
    case ADC3_BASE:
      /* Enable ADC3 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
  36:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  3a:	2101      	movs	r1, #1
  3c:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:155
      /* Release ADC3 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
  40:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  44:	2100      	movs	r1, #0
  46:	f7ff fffe 	bl	0 <RCC_APB2PeriphResetCmd>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:161
      break; 

    default:
      break;
  }
}
  4a:	bd0e      	pop	{r1, r2, r3, pc}
  4c:	40012800 	.word	0x40012800
  50:	40013c00 	.word	0x40013c00
  54:	40012400 	.word	0x40012400

Disassembly of section .text.ADC_Init:

00000000 <ADC_Init>:
ADC_Init():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:190
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
   0:	680a6843 	.word	0x680a6843
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:192
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
   4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
   8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:196
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
   c:	4313      	orrs	r3, r2
   e:	790a      	ldrb	r2, [r1, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:175
*                    ADC peripheral.
* Output         : None
* Return         : None
******************************************************************************/
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
  10:	b510      	push	{r4, lr}
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:196
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
  12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:198
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
  16:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:209
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  18:	688a      	ldr	r2, [r1, #8]
  1a:	68cb      	ldr	r3, [r1, #12]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:202
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  1c:	6884      	ldr	r4, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:209
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  1e:	431a      	orrs	r2, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:204

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
  20:	4b09      	ldr	r3, [pc, #36]	; (48 <ADC_Init+0x48>)
  22:	ea04 0303 	and.w	r3, r4, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:209
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  26:	ea42 0303 	orr.w	r3, r2, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:210
            ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  2a:	794a      	ldrb	r2, [r1, #5]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:209
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
  2c:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:212
            ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
  30:	6083      	str	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:221
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  32:	7c0b      	ldrb	r3, [r1, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:216
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  34:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:221
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  36:	3b01      	subs	r3, #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:218

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  38:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:222
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  tmpreg1 |= ((u32)tmpreg2 << 20);
  3c:	b2db      	uxtb	r3, r3
  3e:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:224
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
  42:	62c3      	str	r3, [r0, #44]	; 0x2c
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:225
}
  44:	bd10      	pop	{r4, pc}
  46:	bf00      	nop
  48:	fff1f7fd 	.word	0xfff1f7fd

Disassembly of section .text.ADC_StructInit:

00000000 <ADC_StructInit>:
ADC_StructInit():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:239
*******************************************************************************/
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
   0:	2300      	movs	r3, #0
   2:	6003      	str	r3, [r0, #0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:242

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   4:	7103      	strb	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:245

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   6:	7143      	strb	r3, [r0, #5]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:248

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   8:	6083      	str	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:251

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   a:	60c3      	str	r3, [r0, #12]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:254

  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
   c:	3301      	adds	r3, #1
   e:	7403      	strb	r3, [r0, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:255
}
  10:	4770      	bx	lr

Disassembly of section .text.ADC_Cmd:

00000000 <ADC_Cmd>:
ADC_Cmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:272
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_Cmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:275
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f043 0301 	orr.w	r3, r3, #1
   8:	e002      	b.n	10 <ADC_Cmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:280
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f023 0301 	bic.w	r3, r3, #1
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_DMACmd:

00000000 <ADC_DMACmd>:
ADC_DMACmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:300
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DMACmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:303
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   8:	e002      	b.n	10 <ADC_DMACmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:308
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ITConfig:

00000000 <ADC_ITConfig>:
ADC_ITConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:337
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));

  /* Get the ADC IT index */
  itmask = (u8)ADC_IT;
   0:	b2c9      	uxtb	r1, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:339

  if (NewState != DISABLE)
   2:	b112      	cbz	r2, a <ADC_ITConfig+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:342
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
   4:	6843      	ldr	r3, [r0, #4]
   6:	4319      	orrs	r1, r3
   8:	e002      	b.n	10 <ADC_ITConfig+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:347
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(u32)itmask);
   a:	6843      	ldr	r3, [r0, #4]
   c:	ea23 0101 	bic.w	r1, r3, r1
  10:	6041      	str	r1, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ResetCalibration:

00000000 <ADC_ResetCalibration>:
ADC_ResetCalibration():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:364
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0308 	orr.w	r3, r3, #8
   6:	6083      	str	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:365
}
   8:	4770      	bx	lr

Disassembly of section .text.ADC_GetResetCalibrationStatus:

00000000 <ADC_GetResetCalibrationStatus>:
ADC_GetResetCalibrationStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:382

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
   0:	6880      	ldr	r0, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:395
    bitstatus = RESET;
  }

  /* Return the RSTCAL bit status */
  return  bitstatus;
}
   2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_StartCalibration:

00000000 <ADC_StartCalibration>:
ADC_StartCalibration():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:410
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
   0:	6883      	ldr	r3, [r0, #8]
   2:	f043 0304 	orr.w	r3, r3, #4
   6:	6083      	str	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:411
}
   8:	4770      	bx	lr

Disassembly of section .text.ADC_GetCalibrationStatus:

00000000 <ADC_GetCalibrationStatus>:
ADC_GetCalibrationStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:428

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
   0:	6880      	ldr	r0, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:441
    bitstatus = RESET;
  }

  /* Return the CAL bit status */
  return  bitstatus;
}
   2:	f3c0 0080 	ubfx	r0, r0, #2, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_SoftwareStartConvCmd:

00000000 <ADC_SoftwareStartConvCmd>:
ADC_SoftwareStartConvCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:458
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartConvCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:462
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
   8:	e002      	b.n	10 <ADC_SoftwareStartConvCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:468
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetSoftwareStartConvStatus:

00000000 <ADC_GetSoftwareStartConvStatus>:
ADC_GetSoftwareStartConvStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:487

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
   0:	6880      	ldr	r0, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:500
    bitstatus = RESET;
  }

  /* Return the SWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5080 	ubfx	r0, r0, #22, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_DiscModeChannelCountConfig:

00000000 <ADC_DiscModeChannelCountConfig>:
ADC_DiscModeChannelCountConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:522
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));

  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:526
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
   2:	3901      	subs	r1, #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:524
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));

  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
   4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:527
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
   8:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:529
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
   c:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:530
}
   e:	4770      	bx	lr

Disassembly of section .text.ADC_DiscModeCmd:

00000000 <ADC_DiscModeCmd>:
ADC_DiscModeCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:549
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_DiscModeCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:552
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= CR1_DISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   8:	e002      	b.n	10 <ADC_DiscModeCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:557
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= CR1_DISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_RegularChannelConfig:

00000000 <ADC_RegularChannelConfig>:
ADC_RegularChannelConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:613
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:603
*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	ea4f 0441 	mov.w	r4, r1, lsl #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:613
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   8:	d90b      	bls.n	22 <ADC_RegularChannelConfig+0x22>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:618
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
   a:	1864      	adds	r4, r4, r1
   c:	3c1e      	subs	r4, #30
   e:	2507      	movs	r5, #7
  10:	40a5      	lsls	r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:622
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
  12:	40a3      	lsls	r3, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:616

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  14:	68c6      	ldr	r6, [r0, #12]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:620
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
  16:	ea26 0505 	bic.w	r5, r6, r5
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:624
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
  1a:	ea45 0403 	orr.w	r4, r5, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:626
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  1e:	60c4      	str	r4, [r0, #12]
  20:	e00a      	b.n	38 <ADC_RegularChannelConfig+0x38>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:633
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  22:	1864      	adds	r4, r4, r1
  24:	2507      	movs	r5, #7
  26:	40a5      	lsls	r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:637
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
  28:	fa13 f404 	lsls.w	r4, r3, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:631
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  2c:	6906      	ldr	r6, [r0, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:635
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
  2e:	ea26 0505 	bic.w	r5, r6, r5
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:639
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
  32:	ea45 0304 	orr.w	r3, r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:641
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  36:	6103      	str	r3, [r0, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:644
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  38:	2a06      	cmp	r2, #6
  3a:	d80c      	bhi.n	56 <ADC_RegularChannelConfig+0x56>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:649
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
  3c:	3a01      	subs	r2, #1
  3e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  42:	231f      	movs	r3, #31
  44:	4093      	lsls	r3, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:653
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
  46:	4091      	lsls	r1, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:647
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
  48:	6b44      	ldr	r4, [r0, #52]	; 0x34
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:651
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  4a:	ea24 0303 	bic.w	r3, r4, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:655
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  4e:	ea43 0201 	orr.w	r2, r3, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:657
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  52:	6342      	str	r2, [r0, #52]	; 0x34
  54:	bd70      	pop	{r4, r5, r6, pc}
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:660
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  56:	2a0c      	cmp	r2, #12
  58:	ea4f 0382 	mov.w	r3, r2, lsl #2
  5c:	d80b      	bhi.n	76 <ADC_RegularChannelConfig+0x76>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:665
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
  5e:	189a      	adds	r2, r3, r2
  60:	3a23      	subs	r2, #35	; 0x23
  62:	231f      	movs	r3, #31
  64:	4093      	lsls	r3, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:669
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
  66:	4091      	lsls	r1, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:663
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
  68:	6b04      	ldr	r4, [r0, #48]	; 0x30
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:667
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  6a:	ea24 0303 	bic.w	r3, r4, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:671
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  6e:	ea43 0201 	orr.w	r2, r3, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:673
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
  72:	6302      	str	r2, [r0, #48]	; 0x30
  74:	bd70      	pop	{r4, r5, r6, pc}
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:681
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
  76:	189a      	adds	r2, r3, r2
  78:	3a41      	subs	r2, #65	; 0x41
  7a:	231f      	movs	r3, #31
  7c:	4093      	lsls	r3, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:685
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
  7e:	4091      	lsls	r1, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:679
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
  80:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:683
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
  82:	ea24 0303 	bic.w	r3, r4, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:687
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
  86:	ea43 0201 	orr.w	r2, r3, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:689
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  8a:	62c2      	str	r2, [r0, #44]	; 0x2c
  8c:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.ADC_ExternalTrigConvCmd:

00000000 <ADC_ExternalTrigConvCmd>:
ADC_ExternalTrigConvCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:709
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigConvCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:712
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8:	e002      	b.n	10 <ADC_ExternalTrigConvCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:717
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetConversionValue:

00000000 <ADC_GetConversionValue>:
ADC_GetConversionValue():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:734
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC conversion value */
  return (u16) ADCx->DR;
   0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:735
}
   2:	b280      	uxth	r0, r0
   4:	4770      	bx	lr

Disassembly of section .text.ADC_GetDualModeConversionValue:

00000000 <ADC_GetDualModeConversionValue>:
ADC_GetDualModeConversionValue():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:746
* Return         : The Data conversion value.
*******************************************************************************/
u32 ADC_GetDualModeConversionValue(void)
{
  /* Return the dual mode conversion value */
  return (*(vu32 *) DR_ADDRESS);
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <ADC_GetDualModeConversionValue+0x8>)
   2:	6818      	ldr	r0, [r3, #0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:747
}
   4:	4770      	bx	lr
   6:	bf00      	nop
   8:	4001244c 	.word	0x4001244c

Disassembly of section .text.ADC_AutoInjectedConvCmd:

00000000 <ADC_AutoInjectedConvCmd>:
ADC_AutoInjectedConvCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:766
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_AutoInjectedConvCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:769
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= CR1_JAUTO_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   8:	e002      	b.n	10 <ADC_AutoInjectedConvCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:774
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= CR1_JAUTO_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_InjectedDiscModeCmd:

00000000 <ADC_InjectedDiscModeCmd>:
ADC_InjectedDiscModeCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:795
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_InjectedDiscModeCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:798
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= CR1_JDISCEN_Set;
   2:	6843      	ldr	r3, [r0, #4]
   4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   8:	e002      	b.n	10 <ADC_InjectedDiscModeCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:803
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= CR1_JDISCEN_Reset;
   a:	6843      	ldr	r3, [r0, #4]
   c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  10:	6043      	str	r3, [r0, #4]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_ExternalTrigInjectedConvConfig:

00000000 <ADC_ExternalTrigInjectedConvConfig>:
ADC_ExternalTrigInjectedConvConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:854
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));

  /* Get the old register value */
  tmpreg = ADCx->CR2;
   0:	6883      	ldr	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:856
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_Reset;
   2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:858
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
   6:	ea41 0303 	orr.w	r3, r1, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:860
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
   a:	6083      	str	r3, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:861
}
   c:	4770      	bx	lr

Disassembly of section .text.ADC_ExternalTrigInjectedConvCmd:

00000000 <ADC_ExternalTrigInjectedConvCmd>:
ADC_ExternalTrigInjectedConvCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:880
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_ExternalTrigInjectedConvCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:883
  {
    /* Enable the selected ADC external event selection for injected group */
    ADCx->CR2 |= CR2_JEXTTRIG_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8:	e002      	b.n	10 <ADC_ExternalTrigInjectedConvCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:888
  }
  else
  {
    /* Disable the selected ADC external event selection for injected group */
    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_SoftwareStartInjectedConvCmd:

00000000 <ADC_SoftwareStartInjectedConvCmd>:
ADC_SoftwareStartInjectedConvCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:909
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   0:	b119      	cbz	r1, a <ADC_SoftwareStartInjectedConvCmd+0xa>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:913
  {
    /* Enable the selected ADC conversion for injected group on external event and start the selected
       ADC injected conversion */
    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   2:	6883      	ldr	r3, [r0, #8]
   4:	f443 1302 	orr.w	r3, r3, #2129920	; 0x208000
   8:	e002      	b.n	10 <ADC_SoftwareStartInjectedConvCmd+0x10>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:919
  }
  else
  {
    /* Disable the selected ADC conversion on external event for injected group and stop the selected
       ADC injected conversion */
    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   a:	6883      	ldr	r3, [r0, #8]
   c:	f423 1302 	bic.w	r3, r3, #2129920	; 0x208000
  10:	6083      	str	r3, [r0, #8]
  12:	4770      	bx	lr

Disassembly of section .text.ADC_GetSoftwareStartInjectedConvCmdStatus:

00000000 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
ADC_GetSoftwareStartInjectedConvCmdStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:938

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
   0:	6880      	ldr	r0, [r0, #8]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:951
    bitstatus = RESET;
  }

  /* Return the JSWSTART bit status */
  return  bitstatus;
}
   2:	f3c0 5040 	ubfx	r0, r0, #21, #1
   6:	4770      	bx	lr

Disassembly of section .text.ADC_InjectedChannelConfig:

00000000 <ADC_InjectedChannelConfig>:
ADC_InjectedChannelConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1005
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   0:	2909      	cmp	r1, #9
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:995
*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	ea4f 0441 	mov.w	r4, r1, lsl #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1005
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
   8:	d90b      	bls.n	22 <ADC_InjectedChannelConfig+0x22>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1010
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   a:	1864      	adds	r4, r4, r1
   c:	3c1e      	subs	r4, #30
   e:	2507      	movs	r5, #7
  10:	40a5      	lsls	r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1014
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
  12:	40a3      	lsls	r3, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1008

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
  14:	68c6      	ldr	r6, [r0, #12]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1012
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
  16:	ea26 0505 	bic.w	r5, r6, r5
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1016
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
  1a:	ea45 0403 	orr.w	r4, r5, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1018
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
  1e:	60c4      	str	r4, [r0, #12]
  20:	e00a      	b.n	38 <ADC_InjectedChannelConfig+0x38>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1025
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
  22:	1864      	adds	r4, r4, r1
  24:	2507      	movs	r5, #7
  26:	40a5      	lsls	r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1029
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
  28:	fa13 f404 	lsls.w	r4, r3, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1023
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
  2c:	6906      	ldr	r6, [r0, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1027
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
  2e:	ea26 0505 	bic.w	r5, r6, r5
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1031
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
  32:	ea45 0304 	orr.w	r3, r5, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1033
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  36:	6103      	str	r3, [r0, #16]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1038
  }

  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  38:	6b83      	ldr	r3, [r0, #56]	; 0x38
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1040
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  3a:	f403 1440 	and.w	r4, r3, #3145728	; 0x300000
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1042
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  3e:	ea6f 5414 	mvn.w	r4, r4, lsr #20
  42:	1912      	adds	r2, r2, r4
  44:	3203      	adds	r2, #3
  46:	b2d2      	uxtb	r2, r2
  48:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4c:	241f      	movs	r4, #31
  4e:	4094      	lsls	r4, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1046
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  50:	4091      	lsls	r1, r2
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1044
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
  52:	ea23 0304 	bic.w	r3, r3, r4
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1048
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
  56:	430b      	orrs	r3, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1050
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
  58:	6383      	str	r3, [r0, #56]	; 0x38
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1051
}
  5a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.ADC_InjectedSequencerLengthConfig:

00000000 <ADC_InjectedSequencerLengthConfig>:
ADC_InjectedSequencerLengthConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1072
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
   0:	6b83      	ldr	r3, [r0, #56]	; 0x38
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1076
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
   2:	3901      	subs	r1, #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1074
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
   4:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1077
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
   8:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1079
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
   c:	6383      	str	r3, [r0, #56]	; 0x38
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1080
}
   e:	4770      	bx	lr

Disassembly of section .text.ADC_SetInjectedOffset:

00000000 <ADC_SetInjectedOffset>:
ADC_SetInjectedOffset():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1099
*                    This parameter must be a 12bit value.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
{
   0:	b082      	sub	sp, #8
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1106
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));  

  /* Set the selected injected channel data offset */
  *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
   2:	500a      	str	r2, [r1, r0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1107
}
   4:	b002      	add	sp, #8
   6:	4770      	bx	lr

Disassembly of section .text.ADC_GetInjectedConversionValue:

00000000 <ADC_GetInjectedConversionValue>:
ADC_GetInjectedConversionValue():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1123
*                       - ADC_InjectedChannel_4: Injected Channel4 selected
* Output         : None
* Return         : The Data conversion value.
*******************************************************************************/
u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
{
   0:	b082      	sub	sp, #8
   2:	9001      	str	r0, [sp, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1129
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  /* Returns the selected injected channel conversion data value */
  return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
   4:	3028      	adds	r0, #40	; 0x28
   6:	5840      	ldr	r0, [r0, r1]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1130
}
   8:	b280      	uxth	r0, r0
   a:	b002      	add	sp, #8
   c:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogCmd:

00000000 <ADC_AnalogWatchdogCmd>:
ADC_AnalogWatchdogCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1165
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));

  /* Get the old register value */
  tmpreg = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1167
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= CR1_AWDMode_Reset;
   2:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
   6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1169
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
   a:	ea41 0303 	orr.w	r3, r1, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1171
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   e:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1172
}
  10:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogThresholdsConfig:

00000000 <ADC_AnalogWatchdogThresholdsConfig>:
ADC_AnalogWatchdogThresholdsConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1194
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));

  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
   0:	6241      	str	r1, [r0, #36]	; 0x24
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1196
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
   2:	6282      	str	r2, [r0, #40]	; 0x28
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1197
}
   4:	4770      	bx	lr

Disassembly of section .text.ADC_AnalogWatchdogSingleChannelConfig:

00000000 <ADC_AnalogWatchdogSingleChannelConfig>:
ADC_AnalogWatchdogSingleChannelConfig():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1236
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));

  /* Get the old register value */
  tmpreg = ADCx->CR1;
   0:	6843      	ldr	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1238
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_Reset;
   2:	f023 031f 	bic.w	r3, r3, #31
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1240
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
   6:	ea41 0303 	orr.w	r3, r1, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1242
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
   a:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1243
}
   c:	4770      	bx	lr

Disassembly of section .text.ADC_TempSensorVrefintCmd:

00000000 <ADC_TempSensorVrefintCmd>:
ADC_TempSensorVrefintCmd():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1254
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_TempSensorVrefintCmd(FunctionalState NewState)
{
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <ADC_TempSensorVrefintCmd+0x18>)
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1258
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
   2:	b118      	cbz	r0, c <ADC_TempSensorVrefintCmd+0xc>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1261
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC1->CR2 |= CR2_TSVREFE_Set;
   4:	689a      	ldr	r2, [r3, #8]
   6:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
   a:	e002      	b.n	12 <ADC_TempSensorVrefintCmd+0x12>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1266
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC1->CR2 &= CR2_TSVREFE_Reset;
   c:	689a      	ldr	r2, [r3, #8]
   e:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
  12:	609a      	str	r2, [r3, #8]
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40012400 	.word	0x40012400

Disassembly of section .text.ADC_GetFlagStatus:

00000000 <ADC_GetFlagStatus>:
ADC_GetFlagStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1293
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
   0:	6803      	ldr	r3, [r0, #0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1296
  {
    /* ADC_FLAG is set */
    bitstatus = SET;
   2:	4219      	tst	r1, r3
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1306
    bitstatus = RESET;
  }

  /* Return the ADC_FLAG status */
  return  bitstatus;
}
   4:	bf0c      	ite	eq
   6:	2000      	moveq	r0, #0
   8:	2001      	movne	r0, #1
   a:	4770      	bx	lr

Disassembly of section .text.ADC_ClearFlag:

00000000 <ADC_ClearFlag>:
ADC_ClearFlag():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1329
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(u32)ADC_FLAG;
   0:	43c9      	mvns	r1, r1
   2:	6001      	str	r1, [r0, #0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1330
}
   4:	4770      	bx	lr

Disassembly of section .text.ADC_GetITStatus:

00000000 <ADC_GetITStatus>:
ADC_GetITStatus():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1357

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
   0:	6843      	ldr	r3, [r0, #4]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1360

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
   2:	6800      	ldr	r0, [r0, #0]
   4:	ea10 2011 	ands.w	r0, r0, r1, lsr #8
   8:	d004      	beq.n	14 <ADC_GetITStatus+0x14>
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1357

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
   a:	b2c9      	uxtb	r1, r1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1363

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
  {
    /* ADC_IT is set */
    bitstatus = SET;
   c:	4219      	tst	r1, r3
   e:	bf0c      	ite	eq
  10:	2000      	moveq	r0, #0
  12:	2001      	movne	r0, #1
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1373
    bitstatus = RESET;
  }

  /* Return the ADC_IT status */
  return  bitstatus;
}
  14:	4770      	bx	lr

Disassembly of section .text.ADC_ClearITPendingBit:

00000000 <ADC_ClearITPendingBit>:
ADC_ClearITPendingBit():
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1399

  /* Get the ADC IT index */
  itmask = (u8)(ADC_IT >> 8);

  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(u32)itmask;
   0:	ea6f 2111 	mvn.w	r1, r1, lsr #8
   4:	6001      	str	r1, [r0, #0]
C:\cortex\dimmers\stlibrary\src/stm32f10x_adc.c:1400
}
   6:	4770      	bx	lr
