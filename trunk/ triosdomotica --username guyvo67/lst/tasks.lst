
C:\cortex\dimmers\hex\tasks.o:     file format elf32-littlearm
C:\cortex\dimmers\hex\tasks.o

Disassembly of section .text.xTaskIsTaskSuspended:

00000000 <xTaskIsTaskSuspended>:
xTaskIsTaskSuspended():
C:\cortex\dimmers\rtos\src/tasks.c:863
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   0:	6942      	ldr	r2, [r0, #20]
   2:	4b07      	ldr	r3, [pc, #28]	(20 <xTaskIsTaskSuspended+0x20>)
   4:	429a      	cmp	r2, r3
   6:	d109      	bne.n	1c <xTaskIsTaskSuspended+0x1c>
C:\cortex\dimmers\rtos\src/tasks.c:866
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
   8:	6a80      	ldr	r0, [r0, #40]
   a:	f102 0314 	add.w	r3, r2, #20	; 0x14
   e:	4298      	cmp	r0, r3
  10:	d004      	beq.n	1c <xTaskIsTaskSuspended+0x1c>
  12:	f1d0 0001 	rsbs	r0, r0, #1	; 0x1
  16:	bf38      	it	cc
  18:	2000      	movcc	r0, #0
  1a:	e000      	b.n	1e <xTaskIsTaskSuspended+0x1e>
  1c:	2000      	movs	r0, #0
C:\cortex\dimmers\rtos\src/tasks.c:880
				}
			}
		}

		return xReturn;
	}
  1e:	4770      	bx	lr
  20:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskSuspendAll:

00000000 <vTaskSuspendAll>:
vTaskSuspendAll():
C:\cortex\dimmers\rtos\src/tasks.c:1020

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
   0:	4a02      	ldr	r2, [pc, #8]	(c <vTaskSuspendAll+0xc>)
   2:	6a93      	ldr	r3, [r2, #40]
   4:	3301      	adds	r3, #1
   6:	6293      	str	r3, [r2, #40]
C:\cortex\dimmers\rtos\src/tasks.c:1021
}
   8:	4770      	bx	lr
   a:	46c0      	nop			(mov r8, r8)
   c:	00000000 	.word	0x00000000
Disassembly of section .text.uxTaskGetNumberOfTasks:

00000000 <uxTaskGetNumberOfTasks>:
uxTaskGetNumberOfTasks():
C:\cortex\dimmers\rtos\src/tasks.c:1125

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
   0:	4b01      	ldr	r3, [pc, #4]	(8 <uxTaskGetNumberOfTasks+0x8>)
   2:	6ad8      	ldr	r0, [r3, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1126
}
   4:	4770      	bx	lr
   6:	46c0      	nop			(mov r8, r8)
   8:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskSwitchContext:

00000000 <vTaskSwitchContext>:
vTaskSwitchContext():
C:\cortex\dimmers\rtos\src/tasks.c:1397

void vTaskSwitchContext( void )
{
	traceTASK_SWITCHED_OUT();

	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   0:	4a11      	ldr	r2, [pc, #68]	(48 <vTaskSwitchContext+0x48>)
   2:	6a93      	ldr	r3, [r2, #40]
   4:	b12b      	cbz	r3, 12 <vTaskSwitchContext+0x12>
C:\cortex\dimmers\rtos\src/tasks.c:1401
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
   6:	2301      	movs	r3, #1
   8:	6313      	str	r3, [r2, #48]
   a:	e01c      	b.n	46 <vTaskSwitchContext+0x46>
C:\cortex\dimmers\rtos\src/tasks.c:1411
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
   c:	6b53      	ldr	r3, [r2, #52]
   e:	3b01      	subs	r3, #1
  10:	6353      	str	r3, [r2, #52]
C:\cortex\dimmers\rtos\src/tasks.c:1409

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  12:	4a0d      	ldr	r2, [pc, #52]	(48 <vTaskSwitchContext+0x48>)
  14:	2114      	movs	r1, #20
  16:	6b53      	ldr	r3, [r2, #52]
  18:	f102 0038 	add.w	r0, r2, #56	; 0x38
  1c:	434b      	muls	r3, r1
  1e:	58c3      	ldr	r3, [r0, r3]
  20:	2b00      	cmp	r3, #0
  22:	d0f3      	beq.n	c <vTaskSwitchContext+0xc>
C:\cortex\dimmers\rtos\src/tasks.c:1416
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  24:	6b53      	ldr	r3, [r2, #52]
  26:	fb01 0103 	mla	r1, r1, r3, r0
  2a:	684b      	ldr	r3, [r1, #4]
  2c:	685a      	ldr	r2, [r3, #4]
  2e:	f101 0308 	add.w	r3, r1, #8	; 0x8
  32:	604a      	str	r2, [r1, #4]
  34:	429a      	cmp	r2, r3
  36:	bf04      	itt	eq
  38:	6853      	ldreq	r3, [r2, #4]
  3a:	604b      	streq	r3, [r1, #4]
  3c:	684b      	ldr	r3, [r1, #4]
  3e:	68da      	ldr	r2, [r3, #12]
  40:	4b01      	ldr	r3, [pc, #4]	(48 <vTaskSwitchContext+0x48>)
  42:	f8c3 209c 	str.w	r2, [r3, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1420

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
  46:	4770      	bx	lr
  48:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskSetTimeOutState:

00000000 <vTaskSetTimeOutState>:
vTaskSetTimeOutState():
C:\cortex\dimmers\rtos\src/tasks.c:1542
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
   0:	4a03      	ldr	r2, [pc, #12]	(10 <vTaskSetTimeOutState+0x10>)
   2:	f8d2 30a0 	ldr.w	r3, [r2, #160]
   6:	6003      	str	r3, [r0, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1543
    pxTimeOut->xTimeOnEntering = xTickCount;
   8:	f8d2 30a4 	ldr.w	r3, [r2, #164]
   c:	6043      	str	r3, [r0, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1544
}
   e:	4770      	bx	lr
  10:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskMissedYield:

00000000 <vTaskMissedYield>:
vTaskMissedYield():
C:\cortex\dimmers\rtos\src/tasks.c:1592
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
   0:	4b01      	ldr	r3, [pc, #4]	(8 <vTaskMissedYield+0x8>)
   2:	2201      	movs	r2, #1
   4:	631a      	str	r2, [r3, #48]
C:\cortex\dimmers\rtos\src/tasks.c:1593
}
   6:	4770      	bx	lr
   8:	00000000 	.word	0x00000000
Disassembly of section .text.usTaskCheckFreeStackSpace:

00000000 <usTaskCheckFreeStackSpace>:
usTaskCheckFreeStackSpace():
C:\cortex\dimmers\rtos\src/tasks.c:1839
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
   0:	4601      	mov	r1, r0
   2:	2200      	movs	r2, #0
C:\cortex\dimmers\rtos\src/tasks.c:1842
	register unsigned portSHORT usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   4:	5c8b      	ldrb	r3, [r1, r2]
C:\cortex\dimmers\rtos\src/tasks.c:1839
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
   6:	b290      	uxth	r0, r2
C:\cortex\dimmers\rtos\src/tasks.c:1842
	register unsigned portSHORT usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   8:	3201      	adds	r2, #1
   a:	2ba5      	cmp	r3, #165
   c:	d0fa      	beq.n	4 <usTaskCheckFreeStackSpace+0x4>
C:\cortex\dimmers\rtos\src/tasks.c:1851
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
	}
   e:	0880      	lsrs	r0, r0, #2
  10:	4770      	bx	lr
  12:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.uxTaskGetStackHighWaterMark:

00000000 <uxTaskGetStackHighWaterMark>:
uxTaskGetStackHighWaterMark():
C:\cortex\dimmers\rtos\src/tasks.c:1859
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
   0:	b510      	push	{r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1863
	tskTCB *pxTCB;
	unsigned portCHAR *pcEndOfStack;

		pxTCB = prvGetTCBFromHandle( xTask );
   2:	b910      	cbnz	r0, a <uxTaskGetStackHighWaterMark+0xa>
   4:	4b03      	ldr	r3, [pc, #12]	(14 <uxTaskGetStackHighWaterMark+0x14>)
   6:	f8d3 009c 	ldr.w	r0, [r3, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1875
		{
			pcEndOfStack = ( unsigned portCHAR * ) pxTCB->pxEndOfStack;
		}
		#endif

		return usTaskCheckFreeStackSpace( pcEndOfStack );
   a:	6b00      	ldr	r0, [r0, #48]
   c:	f7ff fffe 	bl	0 <uxTaskGetStackHighWaterMark>
C:\cortex\dimmers\rtos\src/tasks.c:1876
	}
  10:	bd10      	pop	{r4, pc}
  12:	46c0      	nop			(mov r8, r8)
  14:	00000000 	.word	0x00000000
Disassembly of section .text.xTaskGetCurrentTaskHandle:

00000000 <xTaskGetCurrentTaskHandle>:
xTaskGetCurrentTaskHandle():
C:\cortex\dimmers\rtos\src/tasks.c:1903
	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		return pxCurrentTCB;
   0:	4b01      	ldr	r3, [pc, #4]	(8 <xTaskGetCurrentTaskHandle+0x8>)
   2:	f8d3 009c 	ldr.w	r0, [r3, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1904
	}
   6:	4770      	bx	lr
   8:	00000000 	.word	0x00000000
Disassembly of section .text.xTaskGetSchedulerState:

00000000 <xTaskGetSchedulerState>:
xTaskGetSchedulerState():
C:\cortex\dimmers\rtos\src/tasks.c:1916

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;
	
		if( xSchedulerRunning == pdFALSE )
   0:	4b04      	ldr	r3, [pc, #16]	(14 <xTaskGetSchedulerState+0x14>)
   2:	f8d3 00a8 	ldr.w	r0, [r3, #168]
   6:	b120      	cbz	r0, 12 <xTaskGetSchedulerState+0x12>
C:\cortex\dimmers\rtos\src/tasks.c:1922
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   8:	6a9b      	ldr	r3, [r3, #40]
   a:	2b00      	cmp	r3, #0
   c:	bf0c      	ite	eq
   e:	2001      	moveq	r0, #1
  10:	2002      	movne	r0, #2
C:\cortex\dimmers\rtos\src/tasks.c:1933
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}
		
		return xReturn;
	}
  12:	4770      	bx	lr
  14:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskPriorityDisinherit:

00000000 <vTaskPriorityDisinherit>:
vTaskPriorityDisinherit():
C:\cortex\dimmers\rtos\src/tasks.c:1973
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )	

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1976
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
   2:	4604      	mov	r4, r0
   4:	b1c0      	cbz	r0, 38 <vTaskPriorityDisinherit+0x38>
C:\cortex\dimmers\rtos\src/tasks.c:1978
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   6:	6ac2      	ldr	r2, [r0, #44]
   8:	6c43      	ldr	r3, [r0, #68]
   a:	429a      	cmp	r2, r3
   c:	d014      	beq.n	38 <vTaskPriorityDisinherit+0x38>
C:\cortex\dimmers\rtos\src/tasks.c:1982
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
   e:	1d05      	adds	r5, r0, #4
  10:	4628      	mov	r0, r5
  12:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1986

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  16:	6c62      	ldr	r2, [r4, #68]
C:\cortex\dimmers\rtos\src/tasks.c:1988
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  18:	4908      	ldr	r1, [pc, #32]	(3c <vTaskPriorityDisinherit+0x3c>)
C:\cortex\dimmers\rtos\src/tasks.c:1987
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  1a:	f1c2 0305 	rsb	r3, r2, #5	; 0x5
C:\cortex\dimmers\rtos\src/tasks.c:1986
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  1e:	62e2      	str	r2, [r4, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1987
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  20:	61a3      	str	r3, [r4, #24]
C:\cortex\dimmers\rtos\src/tasks.c:1988
				prvAddTaskToReadyQueue( pxTCB );
  22:	6b4b      	ldr	r3, [r1, #52]
  24:	4806      	ldr	r0, [pc, #24]	(40 <vTaskPriorityDisinherit+0x40>)
  26:	429a      	cmp	r2, r3
  28:	bf88      	it	hi
  2a:	634a      	strhi	r2, [r1, #52]
  2c:	2314      	movs	r3, #20
  2e:	fb03 0002 	mla	r0, r3, r2, r0
  32:	4629      	mov	r1, r5
  34:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1991
			}
		}
	}
  38:	bd70      	pop	{r4, r5, r6, pc}
  3a:	46c0      	nop			(mov r8, r8)
  3c:	00000000 	.word	0x00000000
  40:	00000038 	.word	0x00000038
Disassembly of section .text.vTaskPriorityInherit:

00000000 <vTaskPriorityInherit>:
vTaskPriorityInherit():
C:\cortex\dimmers\rtos\src/tasks.c:1941
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )
	
	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1944
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   2:	4d17      	ldr	r5, [pc, #92]	(60 <vTaskPriorityInherit+0x60>)
   4:	6ac1      	ldr	r1, [r0, #44]
   6:	f8d5 309c 	ldr.w	r3, [r5, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1941
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )
	
	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   a:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:1944
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   c:	6adb      	ldr	r3, [r3, #44]
   e:	4299      	cmp	r1, r3
  10:	d225      	bcs.n	5e <vTaskPriorityInherit+0x5e>
C:\cortex\dimmers\rtos\src/tasks.c:1947
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  12:	f8d5 309c 	ldr.w	r3, [r5, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1951

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  16:	f105 0238 	add.w	r2, r5, #56	; 0x38
C:\cortex\dimmers\rtos\src/tasks.c:1947
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  1a:	6adb      	ldr	r3, [r3, #44]
  1c:	f1c3 0305 	rsb	r3, r3, #5	; 0x5
  20:	6183      	str	r3, [r0, #24]
C:\cortex\dimmers\rtos\src/tasks.c:1951

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  22:	2314      	movs	r3, #20
  24:	fb03 2301 	mla	r3, r3, r1, r2
  28:	6942      	ldr	r2, [r0, #20]
  2a:	429a      	cmp	r2, r3
  2c:	d113      	bne.n	56 <vTaskPriorityInherit+0x56>
C:\cortex\dimmers\rtos\src/tasks.c:1953
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  2e:	1d06      	adds	r6, r0, #4
  30:	4630      	mov	r0, r6
  32:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1956

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  36:	f8d5 309c 	ldr.w	r3, [r5, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1957
				prvAddTaskToReadyQueue( pxTCB );
  3a:	480a      	ldr	r0, [pc, #40]	(64 <vTaskPriorityInherit+0x64>)
C:\cortex\dimmers\rtos\src/tasks.c:1956
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  3c:	6ada      	ldr	r2, [r3, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1957
				prvAddTaskToReadyQueue( pxTCB );
  3e:	4631      	mov	r1, r6
C:\cortex\dimmers\rtos\src/tasks.c:1956
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40:	62e2      	str	r2, [r4, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1957
				prvAddTaskToReadyQueue( pxTCB );
  42:	6b6b      	ldr	r3, [r5, #52]
  44:	429a      	cmp	r2, r3
  46:	bf88      	it	hi
  48:	636a      	strhi	r2, [r5, #52]
  4a:	2314      	movs	r3, #20
  4c:	fb03 0002 	mla	r0, r3, r2, r0
  50:	f7ff fffe 	bl	0 <vListInsertEnd>
  54:	e003      	b.n	5e <vTaskPriorityInherit+0x5e>
C:\cortex\dimmers\rtos\src/tasks.c:1962
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  56:	f8d5 309c 	ldr.w	r3, [r5, #156]
  5a:	6adb      	ldr	r3, [r3, #44]
  5c:	62c3      	str	r3, [r0, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1965
			}
		}
	}
  5e:	bd70      	pop	{r4, r5, r6, pc}
  60:	00000000 	.word	0x00000000
  64:	00000038 	.word	0x00000038
Disassembly of section .text.xTaskRemoveFromEventList:

00000000 <xTaskRemoveFromEventList>:
xTaskRemoveFromEventList():
C:\cortex\dimmers\rtos\src/tasks.c:1508
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   0:	6803      	ldr	r3, [r0, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1494
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
   2:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1508
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   4:	b90b      	cbnz	r3, a <xTaskRemoveFromEventList+0xa>
   6:	461d      	mov	r5, r3
   8:	e001      	b.n	e <xTaskRemoveFromEventList+0xe>
   a:	68c3      	ldr	r3, [r0, #12]
   c:	68dd      	ldr	r5, [r3, #12]
C:\cortex\dimmers\rtos\src/tasks.c:1509
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
   e:	f105 0618 	add.w	r6, r5, #24	; 0x18
C:\cortex\dimmers\rtos\src/tasks.c:1511

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  12:	4c11      	ldr	r4, [pc, #68]	(58 <xTaskRemoveFromEventList+0x58>)
C:\cortex\dimmers\rtos\src/tasks.c:1509
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  14:	4630      	mov	r0, r6
  16:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1511

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  1a:	6aa3      	ldr	r3, [r4, #40]
  1c:	b96b      	cbnz	r3, 3a <xTaskRemoveFromEventList+0x3a>
C:\cortex\dimmers\rtos\src/tasks.c:1513
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  1e:	1d2e      	adds	r6, r5, #4
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1514
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  26:	6aea      	ldr	r2, [r5, #44]
  28:	6b63      	ldr	r3, [r4, #52]
  2a:	480c      	ldr	r0, [pc, #48]	(5c <xTaskRemoveFromEventList+0x5c>)
  2c:	429a      	cmp	r2, r3
  2e:	bf88      	it	hi
  30:	6362      	strhi	r2, [r4, #52]
  32:	2314      	movs	r3, #20
  34:	fb03 0002 	mla	r0, r3, r2, r0
  38:	e001      	b.n	3e <xTaskRemoveFromEventList+0x3e>
C:\cortex\dimmers\rtos\src/tasks.c:1520
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  3a:	f104 0014 	add.w	r0, r4, #20	; 0x14
  3e:	4631      	mov	r1, r6
  40:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1523
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  44:	4b04      	ldr	r3, [pc, #16]	(58 <xTaskRemoveFromEventList+0x58>)
  46:	6aea      	ldr	r2, [r5, #44]
  48:	f8d3 309c 	ldr.w	r3, [r3, #156]
  4c:	6ad8      	ldr	r0, [r3, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1537
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4e:	4282      	cmp	r2, r0
  50:	bf34      	ite	cc
  52:	2000      	movcc	r0, #0
  54:	2001      	movcs	r0, #1
  56:	bd70      	pop	{r4, r5, r6, pc}
  58:	00000000 	.word	0x00000000
  5c:	00000038 	.word	0x00000038
Disassembly of section .text.vTaskIncrementTick:

00000000 <vTaskIncrementTick>:
vTaskIncrementTick():
C:\cortex\dimmers\rtos\src/tasks.c:1231
void vTaskIncrementTick( void )
{
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   0:	4924      	ldr	r1, [pc, #144]	(94 <vTaskIncrementTick+0x94>)
C:\cortex\dimmers\rtos\src/tasks.c:1227
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
   2:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1231
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   4:	6a8b      	ldr	r3, [r1, #40]
   6:	2b00      	cmp	r3, #0
   8:	d13d      	bne.n	86 <vTaskIncrementTick+0x86>
C:\cortex\dimmers\rtos\src/tasks.c:1233
	{
		++xTickCount;
   a:	f8d1 30a4 	ldr.w	r3, [r1, #164]
   e:	3301      	adds	r3, #1
  10:	f8c1 30a4 	str.w	r3, [r1, #164]
C:\cortex\dimmers\rtos\src/tasks.c:1234
		if( xTickCount == ( portTickType ) 0 )
  14:	f8d1 30a4 	ldr.w	r3, [r1, #164]
  18:	bb4b      	cbnz	r3, 6e <vTaskIncrementTick+0x6e>
C:\cortex\dimmers\rtos\src/tasks.c:1241
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
  1a:	f8d1 20ac 	ldr.w	r2, [r1, #172]
C:\cortex\dimmers\rtos\src/tasks.c:1242
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  1e:	f8d1 30b0 	ldr.w	r3, [r1, #176]
  22:	f8c1 30ac 	str.w	r3, [r1, #172]
C:\cortex\dimmers\rtos\src/tasks.c:1243
			pxOverflowDelayedTaskList = pxTemp;
  26:	f8c1 20b0 	str.w	r2, [r1, #176]
C:\cortex\dimmers\rtos\src/tasks.c:1244
            xNumOfOverflows++;
  2a:	f8d1 30a0 	ldr.w	r3, [r1, #160]
  2e:	3301      	adds	r3, #1
  30:	f8c1 30a0 	str.w	r3, [r1, #160]
  34:	e01b      	b.n	6e <vTaskIncrementTick+0x6e>
C:\cortex\dimmers\rtos\src/tasks.c:1248
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  36:	f8d2 20a4 	ldr.w	r2, [r2, #164]
  3a:	6863      	ldr	r3, [r4, #4]
  3c:	429a      	cmp	r2, r3
  3e:	d327      	bcc.n	90 <vTaskIncrementTick+0x90>
  40:	1d25      	adds	r5, r4, #4
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <vListRemove>
  48:	6aa3      	ldr	r3, [r4, #40]
  4a:	b11b      	cbz	r3, 54 <vTaskIncrementTick+0x54>
  4c:	f104 0018 	add.w	r0, r4, #24	; 0x18
  50:	f7ff fffe 	bl	0 <vListRemove>
  54:	490f      	ldr	r1, [pc, #60]	(94 <vTaskIncrementTick+0x94>)
  56:	6ae2      	ldr	r2, [r4, #44]
  58:	6b4b      	ldr	r3, [r1, #52]
  5a:	480f      	ldr	r0, [pc, #60]	(98 <vTaskIncrementTick+0x98>)
  5c:	429a      	cmp	r2, r3
  5e:	bf88      	it	hi
  60:	634a      	strhi	r2, [r1, #52]
  62:	2314      	movs	r3, #20
  64:	fb03 0002 	mla	r0, r3, r2, r0
  68:	4629      	mov	r1, r5
  6a:	f7ff fffe 	bl	0 <vListInsertEnd>
  6e:	4a09      	ldr	r2, [pc, #36]	(94 <vTaskIncrementTick+0x94>)
  70:	f8d2 30ac 	ldr.w	r3, [r2, #172]
  74:	681b      	ldr	r3, [r3, #0]
  76:	b15b      	cbz	r3, 90 <vTaskIncrementTick+0x90>
  78:	f8d2 30ac 	ldr.w	r3, [r2, #172]
  7c:	68db      	ldr	r3, [r3, #12]
  7e:	68dc      	ldr	r4, [r3, #12]
  80:	2c00      	cmp	r4, #0
  82:	d1d8      	bne.n	36 <vTaskIncrementTick+0x36>
  84:	e004      	b.n	90 <vTaskIncrementTick+0x90>
C:\cortex\dimmers\rtos\src/tasks.c:1252
	}
	else
	{
		++uxMissedTicks;
  86:	f8d1 30b4 	ldr.w	r3, [r1, #180]
  8a:	3301      	adds	r3, #1
  8c:	f8c1 30b4 	str.w	r3, [r1, #180]
C:\cortex\dimmers\rtos\src/tasks.c:1279
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  90:	bd70      	pop	{r4, r5, r6, pc}
  92:	46c0      	nop			(mov r8, r8)
  94:	00000000 	.word	0x00000000
  98:	00000038 	.word	0x00000038
Disassembly of section .text.xTaskResumeFromISR:

00000000 <xTaskResumeFromISR>:
xTaskResumeFromISR():
C:\cortex\dimmers\rtos\src/tasks.c:930
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:936
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;

		pxTCB = ( tskTCB * ) pxTaskToResume;

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   6:	f7ff fffe 	bl	0 <xTaskResumeFromISR>
   a:	2801      	cmp	r0, #1
   c:	d122      	bne.n	54 <xTaskResumeFromISR+0x54>
C:\cortex\dimmers\rtos\src/tasks.c:940
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   e:	4d13      	ldr	r5, [pc, #76]	(5c <xTaskResumeFromISR+0x5c>)
  10:	6aab      	ldr	r3, [r5, #40]
  12:	b9cb      	cbnz	r3, 48 <xTaskResumeFromISR+0x48>
C:\cortex\dimmers\rtos\src/tasks.c:943
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
				vListRemove(  &( pxTCB->xGenericListItem ) );	
  14:	1d26      	adds	r6, r4, #4
C:\cortex\dimmers\rtos\src/tasks.c:942
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
  16:	f8d5 309c 	ldr.w	r3, [r5, #156]
C:\cortex\dimmers\rtos\src/tasks.c:943
				vListRemove(  &( pxTCB->xGenericListItem ) );	
  1a:	4630      	mov	r0, r6
C:\cortex\dimmers\rtos\src/tasks.c:942
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
  1c:	6adf      	ldr	r7, [r3, #44]
  1e:	f8d4 802c 	ldr.w	r8, [r4, #44]
C:\cortex\dimmers\rtos\src/tasks.c:943
				vListRemove(  &( pxTCB->xGenericListItem ) );	
  22:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:944
				prvAddTaskToReadyQueue( pxTCB );
  26:	6ae1      	ldr	r1, [r4, #44]
  28:	6b6b      	ldr	r3, [r5, #52]
  2a:	480d      	ldr	r0, [pc, #52]	(60 <xTaskResumeFromISR+0x60>)
  2c:	4299      	cmp	r1, r3
  2e:	bf88      	it	hi
  30:	6369      	strhi	r1, [r5, #52]
  32:	2314      	movs	r3, #20
  34:	fb03 0001 	mla	r0, r3, r1, r0
  38:	4631      	mov	r1, r6
C:\cortex\dimmers\rtos\src/tasks.c:942
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
  3a:	45b8      	cmp	r8, r7
  3c:	bf34      	ite	cc
  3e:	2400      	movcc	r4, #0
  40:	2401      	movcs	r4, #1
C:\cortex\dimmers\rtos\src/tasks.c:944
				vListRemove(  &( pxTCB->xGenericListItem ) );	
				prvAddTaskToReadyQueue( pxTCB );
  42:	f7ff fffe 	bl	0 <vListInsertEnd>
  46:	e006      	b.n	56 <xTaskResumeFromISR+0x56>
C:\cortex\dimmers\rtos\src/tasks.c:951
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
  48:	f105 0014 	add.w	r0, r5, #20	; 0x14
  4c:	f104 0118 	add.w	r1, r4, #24	; 0x18
  50:	f7ff fffe 	bl	0 <vListInsertEnd>
  54:	2400      	movs	r4, #0
C:\cortex\dimmers\rtos\src/tasks.c:956
			}
		}

		return xYieldRequired;
	}
  56:	4620      	mov	r0, r4
  58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  5c:	00000000 	.word	0x00000000
  60:	00000038 	.word	0x00000038
Disassembly of section .text.xTaskCheckForTimeOut:

00000000 <xTaskCheckForTimeOut>:
xTaskCheckForTimeOut():
C:\cortex\dimmers\rtos\src/tasks.c:1548
    pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:1551
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
   6:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1557
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   a:	6829      	ldr	r1, [r5, #0]
   c:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
  10:	d019      	beq.n	46 <xTaskCheckForTimeOut+0x46>
C:\cortex\dimmers\rtos\src/tasks.c:1564
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
  12:	4810      	ldr	r0, [pc, #64]	(54 <xTaskCheckForTimeOut+0x54>)
  14:	6823      	ldr	r3, [r4, #0]
  16:	f8d0 20a0 	ldr.w	r2, [r0, #160]
  1a:	429a      	cmp	r2, r3
  1c:	d004      	beq.n	28 <xTaskCheckForTimeOut+0x28>
  1e:	f8d0 20a4 	ldr.w	r2, [r0, #164]
  22:	6863      	ldr	r3, [r4, #4]
  24:	429a      	cmp	r2, r3
  26:	d210      	bcs.n	4a <xTaskCheckForTimeOut+0x4a>
C:\cortex\dimmers\rtos\src/tasks.c:1572
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
  28:	480a      	ldr	r0, [pc, #40]	(54 <xTaskCheckForTimeOut+0x54>)
  2a:	6862      	ldr	r2, [r4, #4]
  2c:	f8d0 30a4 	ldr.w	r3, [r0, #164]
  30:	1a9b      	subs	r3, r3, r2
  32:	428b      	cmp	r3, r1
  34:	d209      	bcs.n	4a <xTaskCheckForTimeOut+0x4a>
C:\cortex\dimmers\rtos\src/tasks.c:1575
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
  36:	f8d0 30a4 	ldr.w	r3, [r0, #164]
C:\cortex\dimmers\rtos\src/tasks.c:1576
			vTaskSetTimeOutState( pxTimeOut );
  3a:	4620      	mov	r0, r4
C:\cortex\dimmers\rtos\src/tasks.c:1575
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
  3c:	1ad3      	subs	r3, r2, r3
  3e:	185b      	adds	r3, r3, r1
  40:	602b      	str	r3, [r5, #0]
C:\cortex\dimmers\rtos\src/tasks.c:1576
			vTaskSetTimeOutState( pxTimeOut );
  42:	f7ff fffe 	bl	0 <xTaskCheckForTimeOut>
  46:	2400      	movs	r4, #0
  48:	e000      	b.n	4c <xTaskCheckForTimeOut+0x4c>
  4a:	2401      	movs	r4, #1
C:\cortex\dimmers\rtos\src/tasks.c:1584
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
  4c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1587

    return xReturn;
}
  50:	4620      	mov	r0, r4
  52:	bd70      	pop	{r4, r5, r6, pc}
  54:	00000000 	.word	0x00000000
Disassembly of section .text.xTaskGetTickCount:

00000000 <xTaskGetTickCount>:
xTaskGetTickCount():
C:\cortex\dimmers\rtos\src/tasks.c:1107
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
   0:	b510      	push	{r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1111
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   2:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1113
	{
		xTicks = xTickCount;
   6:	4b03      	ldr	r3, [pc, #12]	(14 <xTaskGetTickCount+0x14>)
   8:	f8d3 40a4 	ldr.w	r4, [r3, #164]
C:\cortex\dimmers\rtos\src/tasks.c:1115
	}
	taskEXIT_CRITICAL();
   c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1118

	return xTicks;
}
  10:	4620      	mov	r0, r4
  12:	bd10      	pop	{r4, pc}
  14:	00000000 	.word	0x00000000
Disassembly of section .text.uxTaskPriorityGet:

00000000 <uxTaskPriorityGet>:
uxTaskPriorityGet():
C:\cortex\dimmers\rtos\src/tasks.c:687
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
C:\cortex\dimmers\rtos\src/tasks.c:691
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:695
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
   8:	b91c      	cbnz	r4, 12 <uxTaskPriorityGet+0x12>
   a:	4b05      	ldr	r3, [pc, #20]	(20 <uxTaskPriorityGet+0x20>)
   c:	f8d3 009c 	ldr.w	r0, [r3, #156]
  10:	e000      	b.n	14 <uxTaskPriorityGet+0x14>
  12:	4620      	mov	r0, r4
C:\cortex\dimmers\rtos\src/tasks.c:696
			uxReturn = pxTCB->uxPriority;
  14:	6ac4      	ldr	r4, [r0, #44]
C:\cortex\dimmers\rtos\src/tasks.c:698
		}
		taskEXIT_CRITICAL();
  16:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:701

		return uxReturn;
	}
  1a:	4620      	mov	r0, r4
  1c:	bd10      	pop	{r4, pc}
  1e:	46c0      	nop			(mov r8, r8)
  20:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskPlaceOnEventList:

00000000 <vTaskPlaceOnEventList>:
vTaskPlaceOnEventList():
C:\cortex\dimmers\rtos\src/tasks.c:1424
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1433
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   2:	4c15      	ldr	r4, [pc, #84]	(58 <vTaskPlaceOnEventList+0x58>)
C:\cortex\dimmers\rtos\src/tasks.c:1424
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   4:	460d      	mov	r5, r1
C:\cortex\dimmers\rtos\src/tasks.c:1433
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   6:	f8d4 109c 	ldr.w	r1, [r4, #156]
   a:	3118      	adds	r1, #24
   c:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:1438

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  10:	f8d4 009c 	ldr.w	r0, [r4, #156]
  14:	3004      	adds	r0, #4
  16:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1443


	#if ( INCLUDE_vTaskSuspend == 1 )
	{			
		if( xTicksToWait == portMAX_DELAY )
  1a:	f1b5 3fff 	cmp.w	r5, #4294967295	; 0xffffffff
  1e:	d106      	bne.n	2e <vTaskPlaceOnEventList+0x2e>
C:\cortex\dimmers\rtos\src/tasks.c:1448
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  20:	f8d4 109c 	ldr.w	r1, [r4, #156]
  24:	4620      	mov	r0, r4
  26:	3104      	adds	r1, #4
  28:	f7ff fffe 	bl	0 <vListInsertEnd>
  2c:	e012      	b.n	54 <vTaskPlaceOnEventList+0x54>
C:\cortex\dimmers\rtos\src/tasks.c:1454
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  2e:	f8d4 30a4 	ldr.w	r3, [r4, #164]
C:\cortex\dimmers\rtos\src/tasks.c:1456
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  32:	f8d4 209c 	ldr.w	r2, [r4, #156]
C:\cortex\dimmers\rtos\src/tasks.c:1454
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  36:	18eb      	adds	r3, r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:1456
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  38:	6053      	str	r3, [r2, #4]
C:\cortex\dimmers\rtos\src/tasks.c:1458
		
			if( xTimeToWake < xTickCount )
  3a:	f8d4 20a4 	ldr.w	r2, [r4, #164]
  3e:	4293      	cmp	r3, r2
C:\cortex\dimmers\rtos\src/tasks.c:1461
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40:	bf34      	ite	cc
  42:	f8d4 00b0 	ldrcc.w	r0, [r4, #176]
C:\cortex\dimmers\rtos\src/tasks.c:1466
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  46:	f8d4 00ac 	ldrcs.w	r0, [r4, #172]
  4a:	f8d4 109c 	ldr.w	r1, [r4, #156]
  4e:	3104      	adds	r1, #4
  50:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:1490
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
  54:	bd70      	pop	{r4, r5, r6, pc}
  56:	46c0      	nop			(mov r8, r8)
  58:	00000000 	.word	0x00000000
Disassembly of section .text.xTaskResumeAll:

00000000 <xTaskResumeAll>:
xTaskResumeAll():
C:\cortex\dimmers\rtos\src/tasks.c:1025
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1034
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1036
	{
		--uxSchedulerSuspended;
   8:	4a29      	ldr	r2, [pc, #164]	(b0 <xTaskResumeAll+0xb0>)
   a:	6a93      	ldr	r3, [r2, #40]
   c:	3b01      	subs	r3, #1
   e:	6293      	str	r3, [r2, #40]
C:\cortex\dimmers\rtos\src/tasks.c:1038

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  10:	6a91      	ldr	r1, [r2, #40]
  12:	2900      	cmp	r1, #0
  14:	d146      	bne.n	a4 <xTaskResumeAll+0xa4>
C:\cortex\dimmers\rtos\src/tasks.c:1040
		{			
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  16:	6ad3      	ldr	r3, [r2, #44]
  18:	2b00      	cmp	r3, #0
  1a:	d043      	beq.n	a4 <xTaskResumeAll+0xa4>
  1c:	460e      	mov	r6, r1
  1e:	e01c      	b.n	5a <xTaskResumeAll+0x5a>
C:\cortex\dimmers\rtos\src/tasks.c:1049
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
  20:	1d2f      	adds	r7, r5, #4
C:\cortex\dimmers\rtos\src/tasks.c:1048
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
  22:	f105 0018 	add.w	r0, r5, #24	; 0x18
  26:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1049
					vListRemove( &( pxTCB->xGenericListItem ) );
  2a:	4638      	mov	r0, r7
  2c:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1050
					prvAddTaskToReadyQueue( pxTCB );
  30:	6aea      	ldr	r2, [r5, #44]
  32:	6b63      	ldr	r3, [r4, #52]
  34:	4639      	mov	r1, r7
  36:	429a      	cmp	r2, r3
  38:	bf88      	it	hi
  3a:	6362      	strhi	r2, [r4, #52]
  3c:	4c1c      	ldr	r4, [pc, #112]	(b0 <xTaskResumeAll+0xb0>)
  3e:	2014      	movs	r0, #20
  40:	f104 0338 	add.w	r3, r4, #56	; 0x38
  44:	fb00 3002 	mla	r0, r0, r2, r3
  48:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:1054
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4c:	f8d4 309c 	ldr.w	r3, [r4, #156]
  50:	6aea      	ldr	r2, [r5, #44]
  52:	6adb      	ldr	r3, [r3, #44]
  54:	429a      	cmp	r2, r3
  56:	bf28      	it	cs
  58:	2601      	movcs	r6, #1
C:\cortex\dimmers\rtos\src/tasks.c:1046
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
  5a:	4c15      	ldr	r4, [pc, #84]	(b0 <xTaskResumeAll+0xb0>)
  5c:	6963      	ldr	r3, [r4, #20]
  5e:	b11b      	cbz	r3, 68 <xTaskResumeAll+0x68>
  60:	6a23      	ldr	r3, [r4, #32]
  62:	68dd      	ldr	r5, [r3, #12]
  64:	2d00      	cmp	r5, #0
  66:	d1db      	bne.n	20 <xTaskResumeAll+0x20>
C:\cortex\dimmers\rtos\src/tasks.c:1063
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  68:	4a11      	ldr	r2, [pc, #68]	(b0 <xTaskResumeAll+0xb0>)
  6a:	f8d2 30b4 	ldr.w	r3, [r2, #180]
  6e:	b93b      	cbnz	r3, 80 <xTaskResumeAll+0x80>
  70:	e00c      	b.n	8c <xTaskResumeAll+0x8c>
C:\cortex\dimmers\rtos\src/tasks.c:1067
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
  72:	f7ff fffe 	bl	0 <xTaskResumeAll>
C:\cortex\dimmers\rtos\src/tasks.c:1068
						--uxMissedTicks;
  76:	f8d4 30b4 	ldr.w	r3, [r4, #180]
  7a:	3b01      	subs	r3, #1
  7c:	f8c4 30b4 	str.w	r3, [r4, #180]
C:\cortex\dimmers\rtos\src/tasks.c:1065
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  80:	4c0b      	ldr	r4, [pc, #44]	(b0 <xTaskResumeAll+0xb0>)
  82:	f8d4 30b4 	ldr.w	r3, [r4, #180]
  86:	2b00      	cmp	r3, #0
  88:	d1f3      	bne.n	72 <xTaskResumeAll+0x72>
  8a:	e004      	b.n	96 <xTaskResumeAll+0x96>
C:\cortex\dimmers\rtos\src/tasks.c:1081
						xYieldRequired = pdTRUE;
					}
					#endif
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  8c:	2e01      	cmp	r6, #1
  8e:	d002      	beq.n	96 <xTaskResumeAll+0x96>
  90:	6b13      	ldr	r3, [r2, #48]
  92:	2b01      	cmp	r3, #1
  94:	d106      	bne.n	a4 <xTaskResumeAll+0xa4>
C:\cortex\dimmers\rtos\src/tasks.c:1084
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  96:	4b06      	ldr	r3, [pc, #24]	(b0 <xTaskResumeAll+0xb0>)
  98:	2200      	movs	r2, #0
  9a:	631a      	str	r2, [r3, #48]
C:\cortex\dimmers\rtos\src/tasks.c:1085
					taskYIELD();
  9c:	f7ff fffe 	bl	0 <vPortYieldFromISR>
  a0:	2401      	movs	r4, #1
  a2:	e000      	b.n	a6 <xTaskResumeAll+0xa6>
  a4:	2400      	movs	r4, #0
C:\cortex\dimmers\rtos\src/tasks.c:1090
				}
			}
		}
	}
	portEXIT_CRITICAL();
  a6:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1093

	return xAlreadyYielded;
}
  aa:	4620      	mov	r0, r4
  ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  b0:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskResume:

00000000 <vTaskResume>:
vTaskResume():
C:\cortex\dimmers\rtos\src/tasks.c:888
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:897
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   2:	4605      	mov	r5, r0
   4:	b338      	cbz	r0, 56 <vTaskResume+0x56>
   6:	4c14      	ldr	r4, [pc, #80]	(58 <vTaskResume+0x58>)
   8:	f8d4 309c 	ldr.w	r3, [r4, #156]
   c:	4298      	cmp	r0, r3
   e:	d022      	beq.n	56 <vTaskResume+0x56>
C:\cortex\dimmers\rtos\src/tasks.c:899
		{
			taskENTER_CRITICAL();
  10:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:901
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
  14:	4628      	mov	r0, r5
  16:	f7ff fffe 	bl	0 <vTaskResume>
  1a:	2801      	cmp	r0, #1
  1c:	d119      	bne.n	52 <vTaskResume+0x52>
C:\cortex\dimmers\rtos\src/tasks.c:907
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
  1e:	1d2e      	adds	r6, r5, #4
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:908
					prvAddTaskToReadyQueue( pxTCB );
  26:	6aea      	ldr	r2, [r5, #44]
  28:	6b63      	ldr	r3, [r4, #52]
  2a:	4631      	mov	r1, r6
  2c:	429a      	cmp	r2, r3
  2e:	bf88      	it	hi
  30:	6362      	strhi	r2, [r4, #52]
  32:	4c09      	ldr	r4, [pc, #36]	(58 <vTaskResume+0x58>)
  34:	2014      	movs	r0, #20
  36:	f104 0338 	add.w	r3, r4, #56	; 0x38
  3a:	fb00 3002 	mla	r0, r0, r2, r3
  3e:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:911

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  42:	f8d4 309c 	ldr.w	r3, [r4, #156]
  46:	6aea      	ldr	r2, [r5, #44]
  48:	6adb      	ldr	r3, [r3, #44]
  4a:	429a      	cmp	r2, r3
  4c:	d301      	bcc.n	52 <vTaskResume+0x52>
C:\cortex\dimmers\rtos\src/tasks.c:915
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						taskYIELD();
  4e:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:919
					}
				}
			}
			taskEXIT_CRITICAL();
  52:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:921
		}
	}
  56:	bd70      	pop	{r4, r5, r6, pc}
  58:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskSuspend:

00000000 <vTaskSuspend>:
vTaskSuspend():
C:\cortex\dimmers\rtos\src/tasks.c:814
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
C:\cortex\dimmers\rtos\src/tasks.c:817
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:821
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
   8:	4b10      	ldr	r3, [pc, #64]	(4c <vTaskSuspend+0x4c>)
   a:	f8d3 309c 	ldr.w	r3, [r3, #156]
   e:	429d      	cmp	r5, r3
  10:	d101      	bne.n	16 <vTaskSuspend+0x16>
  12:	2500      	movs	r5, #0
  14:	e000      	b.n	18 <vTaskSuspend+0x18>
C:\cortex\dimmers\rtos\src/tasks.c:827
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
  16:	b91d      	cbnz	r5, 20 <vTaskSuspend+0x20>
  18:	4b0c      	ldr	r3, [pc, #48]	(4c <vTaskSuspend+0x4c>)
  1a:	f8d3 409c 	ldr.w	r4, [r3, #156]
  1e:	e000      	b.n	22 <vTaskSuspend+0x22>
  20:	462c      	mov	r4, r5
C:\cortex\dimmers\rtos\src/tasks.c:832

			traceTASK_SUSPEND( pxTaskToSuspend );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
  22:	1d26      	adds	r6, r4, #4
  24:	4630      	mov	r0, r6
  26:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:835

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
  2a:	6aa3      	ldr	r3, [r4, #40]
  2c:	b11b      	cbz	r3, 36 <vTaskSuspend+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:837
			{
				vListRemove( &( pxTCB->xEventListItem ) );
  2e:	f104 0018 	add.w	r0, r4, #24	; 0x18
  32:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:840
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
  36:	4805      	ldr	r0, [pc, #20]	(4c <vTaskSuspend+0x4c>)
  38:	4631      	mov	r1, r6
  3a:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:842
		}
		taskEXIT_CRITICAL();
  3e:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:845

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
  42:	b90d      	cbnz	r5, 6 <vPortYieldFromISR+0x6>
C:\cortex\dimmers\rtos\src/tasks.c:847
		{
			taskYIELD();
  44:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:849
		}
	}
  48:	bd70      	pop	{r4, r5, r6, pc}
  4a:	46c0      	nop			(mov r8, r8)
  4c:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskPrioritySet:

00000000 <vTaskPrioritySet>:
vTaskPrioritySet():
C:\cortex\dimmers\rtos\src/tasks.c:709
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
   6:	2904      	cmp	r1, #4
   8:	bf34      	ite	cc
   a:	460e      	movcc	r6, r1
   c:	2604      	movcs	r6, #4
C:\cortex\dimmers\rtos\src/tasks.c:719
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - 1;
		}

		taskENTER_CRITICAL();
   e:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:721
		{
			if( pxTask == pxCurrentTCB )
  12:	4b21      	ldr	r3, [pc, #132]	(98 <vTaskPrioritySet+0x98>)
  14:	f8d3 309c 	ldr.w	r3, [r3, #156]
  18:	429d      	cmp	r5, r3
  1a:	d101      	bne.n	20 <vTaskPrioritySet+0x20>
  1c:	2500      	movs	r5, #0
  1e:	e000      	b.n	22 <vTaskPrioritySet+0x22>
C:\cortex\dimmers\rtos\src/tasks.c:728
				pxTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
  20:	b91d      	cbnz	r5, 2a <vTaskPrioritySet+0x2a>
  22:	4b1d      	ldr	r3, [pc, #116]	(98 <vTaskPrioritySet+0x98>)
  24:	f8d3 409c 	ldr.w	r4, [r3, #156]
  28:	e000      	b.n	2c <vTaskPrioritySet+0x2c>
  2a:	462c      	mov	r4, r5
C:\cortex\dimmers\rtos\src/tasks.c:734
			
			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
  2c:	6c61      	ldr	r1, [r4, #68]
C:\cortex\dimmers\rtos\src/tasks.c:742
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
  2e:	42b1      	cmp	r1, r6
  30:	d02d      	beq.n	8e <vTaskPrioritySet+0x8e>
C:\cortex\dimmers\rtos\src/tasks.c:746
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
  32:	428e      	cmp	r6, r1
  34:	d903      	bls.n	3e <vTaskPrioritySet+0x3e>
  36:	1e2f      	subs	r7, r5, #0
  38:	bf18      	it	ne
  3a:	2701      	movne	r7, #1
  3c:	e003      	b.n	46 <vTaskPrioritySet+0x46>
  3e:	f1d5 0701 	rsbs	r7, r5, #1	; 0x1
  42:	bf38      	it	cc
  44:	2700      	movcc	r7, #0
C:\cortex\dimmers\rtos\src/tasks.c:770

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  46:	6ae3      	ldr	r3, [r4, #44]
C:\cortex\dimmers\rtos\src/tasks.c:790

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
  48:	4d13      	ldr	r5, [pc, #76]	(98 <vTaskPrioritySet+0x98>)
C:\cortex\dimmers\rtos\src/tasks.c:770

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  4a:	4299      	cmp	r1, r3
C:\cortex\dimmers\rtos\src/tasks.c:784
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
  4c:	f1c6 0305 	rsb	r3, r6, #5	; 0x5
C:\cortex\dimmers\rtos\src/tasks.c:772
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
					{
						pxTCB->uxPriority = uxNewPriority;
  50:	bf08      	it	eq
  52:	62e6      	streq	r6, [r4, #44]
C:\cortex\dimmers\rtos\src/tasks.c:790

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
  54:	f105 0238 	add.w	r2, r5, #56	; 0x38
C:\cortex\dimmers\rtos\src/tasks.c:784
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
  58:	61a3      	str	r3, [r4, #24]
C:\cortex\dimmers\rtos\src/tasks.c:790

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
  5a:	2314      	movs	r3, #20
  5c:	fb03 2301 	mla	r3, r3, r1, r2
  60:	6962      	ldr	r2, [r4, #20]
C:\cortex\dimmers\rtos\src/tasks.c:776
					{
						pxTCB->uxPriority = uxNewPriority;
					}
					
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;					
  62:	6466      	str	r6, [r4, #68]
C:\cortex\dimmers\rtos\src/tasks.c:790

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
  64:	429a      	cmp	r2, r3
  66:	d10f      	bne.n	88 <vTaskPrioritySet+0x88>
C:\cortex\dimmers\rtos\src/tasks.c:795
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
  68:	1d26      	adds	r6, r4, #4
  6a:	4630      	mov	r0, r6
  6c:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:796
					prvAddTaskToReadyQueue( pxTCB );
  70:	6ae2      	ldr	r2, [r4, #44]
  72:	6b6b      	ldr	r3, [r5, #52]
  74:	4809      	ldr	r0, [pc, #36]	(9c <vTaskPrioritySet+0x9c>)
  76:	429a      	cmp	r2, r3
  78:	bf88      	it	hi
  7a:	636a      	strhi	r2, [r5, #52]
  7c:	2314      	movs	r3, #20
  7e:	fb03 0002 	mla	r0, r3, r2, r0
  82:	4631      	mov	r1, r6
  84:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:799
				}			
				
				if( xYieldRequired == pdTRUE )
  88:	b10f      	cbz	r7, 6 <vPortYieldFromISR+0x6>
C:\cortex\dimmers\rtos\src/tasks.c:801
				{
					taskYIELD();
  8a:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:805
				}				
			}
		}
		taskEXIT_CRITICAL();
  8e:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:806
	}
  92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  96:	46c0      	nop			(mov r8, r8)
  98:	00000000 	.word	0x00000000
  9c:	00000038 	.word	0x00000038
Disassembly of section .text.vTaskDelay:

00000000 <vTaskDelay>:
vTaskDelay():
C:\cortex\dimmers\rtos\src/tasks.c:626
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
   0:	b570      	push	{r4, r5, r6, lr}
C:\cortex\dimmers\rtos\src/tasks.c:631
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
   2:	4606      	mov	r6, r0
   4:	b1e8      	cbz	r0, 42 <vTaskDelay+0x42>
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   6:	4d10      	ldr	r5, [pc, #64]	(48 <vTaskDelay+0x48>)
C:\cortex\dimmers\rtos\src/tasks.c:633
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
   8:	f7ff fffe 	bl	0 <vTaskDelay>
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   c:	f8d5 40a4 	ldr.w	r4, [r5, #164]
C:\cortex\dimmers\rtos\src/tasks.c:652

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  10:	f8d5 009c 	ldr.w	r0, [r5, #156]
C:\cortex\dimmers\rtos\src/tasks.c:647
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  14:	1934      	adds	r4, r6, r4
C:\cortex\dimmers\rtos\src/tasks.c:652

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  16:	3004      	adds	r0, #4
  18:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:655

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  1c:	f8d5 309c 	ldr.w	r3, [r5, #156]
  20:	605c      	str	r4, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:657

				if( xTimeToWake < xTickCount )
  22:	f8d5 30a4 	ldr.w	r3, [r5, #164]
  26:	429c      	cmp	r4, r3
C:\cortex\dimmers\rtos\src/tasks.c:661
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  28:	bf34      	ite	cc
  2a:	f8d5 00b0 	ldrcc.w	r0, [r5, #176]
C:\cortex\dimmers\rtos\src/tasks.c:667
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  2e:	f8d5 00ac 	ldrcs.w	r0, [r5, #172]
  32:	f8d5 109c 	ldr.w	r1, [r5, #156]
  36:	3104      	adds	r1, #4
  38:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:670
				}
			}
			xAlreadyYielded = xTaskResumeAll();
  3c:	f7ff fffe 	bl	0 <vTaskDelay>
C:\cortex\dimmers\rtos\src/tasks.c:675
		}
		
		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
  40:	b908      	cbnz	r0, 6 <vPortYieldFromISR+0x6>
C:\cortex\dimmers\rtos\src/tasks.c:677
		{
			taskYIELD();
  42:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:679
		}
	}
  46:	bd70      	pop	{r4, r5, r6, pc}
  48:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskDelayUntil:

00000000 <vTaskDelayUntil>:
vTaskDelayUntil():
C:\cortex\dimmers\rtos\src/tasks.c:549
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460c      	mov	r4, r1
   4:	4606      	mov	r6, r0
C:\cortex\dimmers\rtos\src/tasks.c:553
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
   6:	f7ff fffe 	bl	0 <vTaskDelayUntil>
C:\cortex\dimmers\rtos\src/tasks.c:558
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
   a:	4919      	ldr	r1, [pc, #100]	(70 <vTaskDelayUntil+0x70>)
C:\cortex\dimmers\rtos\src/tasks.c:556
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   c:	6832      	ldr	r2, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:558

			if( xTickCount < *pxPreviousWakeTime )
   e:	f8d1 30a4 	ldr.w	r3, [r1, #164]
C:\cortex\dimmers\rtos\src/tasks.c:556
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
  12:	18a5      	adds	r5, r4, r2
C:\cortex\dimmers\rtos\src/tasks.c:558

			if( xTickCount < *pxPreviousWakeTime )
  14:	4293      	cmp	r3, r2
  16:	d203      	bcs.n	20 <vTaskDelayUntil+0x20>
C:\cortex\dimmers\rtos\src/tasks.c:565
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
  18:	4295      	cmp	r5, r2
  1a:	d305      	bcc.n	28 <vTaskDelayUntil+0x28>
  1c:	2300      	movs	r3, #0
  1e:	e009      	b.n	34 <vTaskDelayUntil+0x34>
C:\cortex\dimmers\rtos\src/tasks.c:575
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
  20:	4295      	cmp	r5, r2
  22:	d201      	bcs.n	28 <vTaskDelayUntil+0x28>
  24:	2301      	movs	r3, #1
  26:	e005      	b.n	34 <vTaskDelayUntil+0x34>
  28:	f8d1 30a4 	ldr.w	r3, [r1, #164]
  2c:	429d      	cmp	r5, r3
  2e:	bf94      	ite	ls
  30:	2300      	movls	r3, #0
  32:	2301      	movhi	r3, #1
C:\cortex\dimmers\rtos\src/tasks.c:582
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
  34:	6035      	str	r5, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:584

			if( xShouldDelay )
  36:	b1ab      	cbz	r3, 64 <vTaskDelayUntil+0x64>
C:\cortex\dimmers\rtos\src/tasks.c:591
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  38:	4c0d      	ldr	r4, [pc, #52]	(70 <vTaskDelayUntil+0x70>)
  3a:	f8d4 009c 	ldr.w	r0, [r4, #156]
  3e:	3004      	adds	r0, #4
  40:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:594

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  44:	f8d4 309c 	ldr.w	r3, [r4, #156]
  48:	605d      	str	r5, [r3, #4]
C:\cortex\dimmers\rtos\src/tasks.c:596

				if( xTimeToWake < xTickCount )
  4a:	f8d4 30a4 	ldr.w	r3, [r4, #164]
  4e:	429d      	cmp	r5, r3
C:\cortex\dimmers\rtos\src/tasks.c:600
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  50:	bf34      	ite	cc
  52:	f8d4 00b0 	ldrcc.w	r0, [r4, #176]
C:\cortex\dimmers\rtos\src/tasks.c:606
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  56:	f8d4 00ac 	ldrcs.w	r0, [r4, #172]
  5a:	f8d4 109c 	ldr.w	r1, [r4, #156]
  5e:	3104      	adds	r1, #4
  60:	f7ff fffe 	bl	0 <vListInsert>
C:\cortex\dimmers\rtos\src/tasks.c:610
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
  64:	f7ff fffe 	bl	0 <vTaskDelayUntil>
C:\cortex\dimmers\rtos\src/tasks.c:614

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
  68:	b908      	cbnz	r0, 6 <vPortYieldFromISR+0x6>
C:\cortex\dimmers\rtos\src/tasks.c:616
		{
			taskYIELD();
  6a:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:618
		}
	}	
  6e:	bd70      	pop	{r4, r5, r6, pc}
  70:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskDelete:

00000000 <vTaskDelete>:
vTaskDelete():
C:\cortex\dimmers\rtos\src/tasks.c:483
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
C:\cortex\dimmers\rtos\src/tasks.c:486
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
   4:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:490
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
   8:	4b17      	ldr	r3, [pc, #92]	(68 <vTaskDelete+0x68>)
   a:	f8d3 309c 	ldr.w	r3, [r3, #156]
   e:	429d      	cmp	r5, r3
  10:	d101      	bne.n	16 <vTaskDelete+0x16>
  12:	2500      	movs	r5, #0
  14:	e000      	b.n	18 <vTaskDelete+0x18>
C:\cortex\dimmers\rtos\src/tasks.c:496
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  16:	b91d      	cbnz	r5, 20 <vTaskDelete+0x20>
  18:	4b13      	ldr	r3, [pc, #76]	(68 <vTaskDelete+0x68>)
  1a:	f8d3 409c 	ldr.w	r4, [r3, #156]
  1e:	e000      	b.n	22 <vTaskDelete+0x22>
  20:	462c      	mov	r4, r5
C:\cortex\dimmers\rtos\src/tasks.c:504

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
  22:	1d26      	adds	r6, r4, #4
  24:	4630      	mov	r0, r6
  26:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:507

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
  2a:	6aa3      	ldr	r3, [r4, #40]
  2c:	b11b      	cbz	r3, 36 <vTaskDelete+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:509
			{
				vListRemove( &( pxTCB->xEventListItem ) );
  2e:	f104 0018 	add.w	r0, r4, #24	; 0x18
  32:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:512
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  36:	4c0c      	ldr	r4, [pc, #48]	(68 <vTaskDelete+0x68>)
  38:	4631      	mov	r1, r6
  3a:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
  3e:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:517

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  42:	f8d4 30cc 	ldr.w	r3, [r4, #204]
  46:	3301      	adds	r3, #1
  48:	f8c4 30cc 	str.w	r3, [r4, #204]
C:\cortex\dimmers\rtos\src/tasks.c:521

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */			
			uxTaskNumber++;
  4c:	f8d4 30d0 	ldr.w	r3, [r4, #208]
  50:	3301      	adds	r3, #1
  52:	f8c4 30d0 	str.w	r3, [r4, #208]
C:\cortex\dimmers\rtos\src/tasks.c:523
		}
		taskEXIT_CRITICAL();
  56:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:526

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  5a:	f8d4 30a8 	ldr.w	r3, [r4, #168]
  5e:	b113      	cbz	r3, 66 <vTaskDelete+0x66>
C:\cortex\dimmers\rtos\src/tasks.c:528
		{
			if( ( void * ) pxTaskToDelete == NULL )
  60:	b90d      	cbnz	r5, 66 <vTaskDelete+0x66>
C:\cortex\dimmers\rtos\src/tasks.c:530
			{
				taskYIELD();
  62:	f7ff fffe 	bl	0 <vPortYieldFromISR>
C:\cortex\dimmers\rtos\src/tasks.c:533
			}
		}
	}
  66:	bd70      	pop	{r4, r5, r6, pc}
  68:	00000000 	.word	0x00000000
Disassembly of section .text.vTaskEndScheduler:

00000000 <vTaskEndScheduler>:
vTaskEndScheduler():
C:\cortex\dimmers\rtos\src/tasks.c:1006
	}
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
   0:	b510      	push	{r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:1010
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
   2:	f04f 00bf 	mov.w	r0, #191	; 0xbf
   6:	f380 8811 	msr	BASEPRI, r0
C:\cortex\dimmers\rtos\src/tasks.c:1011
	xSchedulerRunning = pdFALSE;
   a:	4b03      	ldr	r3, [pc, #12]	(18 <vTaskEndScheduler+0x18>)
   c:	2200      	movs	r2, #0
   e:	f8c3 20a8 	str.w	r2, [r3, #168]
C:\cortex\dimmers\rtos\src/tasks.c:1012
	vPortEndScheduler();
  12:	f7ff fffe 	bl	0 <vPortEndScheduler>
C:\cortex\dimmers\rtos\src/tasks.c:1013
}
  16:	bd10      	pop	{r4, pc}
  18:	00000000 	.word	0x00000000
Disassembly of section .text.prvIdleTask:

00000000 <prvIdleTask>:
prvIdleTask():
C:\cortex\dimmers\rtos\src/tasks.c:1607
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   0:	b570      	push	{r4, r5, r6, lr}
prvCheckTasksWaitingTermination():
C:\cortex\dimmers\rtos\src/tasks.c:1755
	{				
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
   2:	4d18      	ldr	r5, [pc, #96]	(64 <prvIdleTask+0x64>)
   4:	f8d5 30cc 	ldr.w	r3, [r5, #204]
   8:	b323      	cbz	r3, 4c <prvIdleTask+0x4c>
C:\cortex\dimmers\rtos\src/tasks.c:1757
		{
			vTaskSuspendAll();
   a:	f7ff fffe 	bl	0 <prvIdleTask>
C:\cortex\dimmers\rtos\src/tasks.c:1758
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );				
   e:	f8d5 40b8 	ldr.w	r4, [r5, #184]
C:\cortex\dimmers\rtos\src/tasks.c:1759
			xTaskResumeAll();
  12:	f7ff fffe 	bl	0 <prvIdleTask>
C:\cortex\dimmers\rtos\src/tasks.c:1761

			if( !xListIsEmpty )
  16:	b1ec      	cbz	r4, 3e <vPortEnterCritical+0x3e>
C:\cortex\dimmers\rtos\src/tasks.c:1765
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
  18:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:1767
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  1c:	f8d5 00b8 	ldr.w	r0, [r5, #184]
  20:	b908      	cbnz	r0, 26 <prvIdleTask+0x26>
  22:	4604      	mov	r4, r0
  24:	e002      	b.n	2c <prvIdleTask+0x2c>
  26:	f8d5 30c4 	ldr.w	r3, [r5, #196]
  2a:	68dc      	ldr	r4, [r3, #12]
C:\cortex\dimmers\rtos\src/tasks.c:1768
					vListRemove( &( pxTCB->xGenericListItem ) );
  2c:	1d20      	adds	r0, r4, #4
  2e:	f7ff fffe 	bl	0 <vListRemove>
C:\cortex\dimmers\rtos\src/tasks.c:1769
					--uxCurrentNumberOfTasks;
  32:	4b0c      	ldr	r3, [pc, #48]	(64 <prvIdleTask+0x64>)
  34:	6ada      	ldr	r2, [r3, #44]
  36:	3a01      	subs	r2, #1
  38:	62da      	str	r2, [r3, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1770
					--uxTasksDeleted;
  3a:	f8d3 20cc 	ldr.w	r2, [r3, #204]
  3e:	3a01      	subs	r2, #1
  40:	f8c3 20cc 	str.w	r2, [r3, #204]
C:\cortex\dimmers\rtos\src/tasks.c:1772
				}
				portEXIT_CRITICAL();
  44:	f7ff fffe 	bl	0 <vPortExitCritical>
prvDeleteTCB():
C:\cortex\dimmers\rtos\src/tasks.c:1887

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFree( pxTCB->pxStack );
  48:	6b20      	ldr	r0, [r4, #48]
  4a:	f7ff fffe 	bl	0 <vPortFree>
C:\cortex\dimmers\rtos\src/tasks.c:1888
		vPortFree( pxTCB );
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <vPortFree>
prvIdleTask():
C:\cortex\dimmers\rtos\src/tasks.c:1637
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  54:	4b03      	ldr	r3, [pc, #12]	(64 <prvIdleTask+0x64>)
  56:	6b9b      	ldr	r3, [r3, #56]
  58:	2b01      	cmp	r3, #1
  5a:	d9d2      	bls.n	2 <prvIdleTask+0x2>
C:\cortex\dimmers\rtos\src/tasks.c:1639
			{
				taskYIELD();
  5c:	f7ff fffe 	bl	0 <vPortYieldFromISR>
  60:	e7cf      	b.n	2 <prvIdleTask+0x2>
  62:	46c0      	nop			(mov r8, r8)
  64:	00000000 	.word	0x00000000
Disassembly of section .text.xTaskCreate:

00000000 <xTaskCreate>:
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:358
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4681      	mov	r9, r0
prvAllocateTCBAndStack():
C:\cortex\dimmers\rtos\src/tasks.c:1788
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   6:	2048      	movs	r0, #72
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:358
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
   8:	460d      	mov	r5, r1
   a:	4617      	mov	r7, r2
   c:	4698      	mov	r8, r3
   e:	f8dd b028 	ldr.w	fp, [sp, #40]
prvAllocateTCBAndStack():
C:\cortex\dimmers\rtos\src/tasks.c:1788
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  12:	f7ff fffe 	bl	0 <pvPortMalloc>
C:\cortex\dimmers\rtos\src/tasks.c:1790

	if( pxNewTCB != NULL )
  16:	4606      	mov	r6, r0
  18:	b908      	cbnz	r0, 1e <xTaskCreate+0x1e>
  1a:	3801      	subs	r0, #1
  1c:	e09f      	b.n	15e <xTaskCreate+0x15e>
C:\cortex\dimmers\rtos\src/tasks.c:1795
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
  1e:	00bc      	lsls	r4, r7, #2
  20:	4620      	mov	r0, r4
  22:	f7ff fffe 	bl	0 <pvPortMalloc>
  26:	6330      	str	r0, [r6, #48]
C:\cortex\dimmers\rtos\src/tasks.c:1797

		if( pxNewTCB->pxStack == NULL )
  28:	b928      	cbnz	r0, 36 <xTaskCreate+0x36>
C:\cortex\dimmers\rtos\src/tasks.c:1800
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );			
  2a:	4630      	mov	r0, r6
  2c:	f7ff fffe 	bl	0 <vPortFree>
  30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  34:	e093      	b.n	15e <xTaskCreate+0x15e>
C:\cortex\dimmers\rtos\src/tasks.c:1806
			pxNewTCB = NULL;			
		}		
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
  36:	21a5      	movs	r1, #165
  38:	4622      	mov	r2, r4
  3a:	f7ff fffe 	bl	0 <memset>
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1674


static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
  3e:	2210      	movs	r2, #16
  40:	4629      	mov	r1, r5
  42:	f106 0034 	add.w	r0, r6, #52	; 0x34
  46:	f7ff fffe 	bl	0 <strncpy>
C:\cortex\dimmers\rtos\src/tasks.c:1675
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
  4a:	f1bb 0f04 	cmp.w	fp, #4	; 0x4
  4e:	bf34      	ite	cc
  50:	465c      	movcc	r4, fp
  52:	2404      	movcs	r4, #4
  54:	2300      	movs	r3, #0
C:\cortex\dimmers\rtos\src/tasks.c:1690
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  56:	f106 0a04 	add.w	sl, r6, #4	; 0x4
C:\cortex\dimmers\rtos\src/tasks.c:1675

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
  5a:	f886 3043 	strb.w	r3, [r6, #67]
C:\cortex\dimmers\rtos\src/tasks.c:1683
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
  5e:	62f4      	str	r4, [r6, #44]
C:\cortex\dimmers\rtos\src/tasks.c:1686
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  60:	6474      	str	r4, [r6, #68]
C:\cortex\dimmers\rtos\src/tasks.c:1690
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  62:	4650      	mov	r0, sl
  64:	f7ff fffe 	bl	0 <vListInitialiseItem>
C:\cortex\dimmers\rtos\src/tasks.c:1691
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  68:	f106 0018 	add.w	r0, r6, #24	; 0x18
  6c:	f7ff fffe 	bl	0 <vListInitialiseItem>
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  70:	6b33      	ldr	r3, [r6, #48]
  72:	f1c7 0201 	rsb	r2, r7, #1	; 0x1
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1698
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  76:	f1c4 0405 	rsb	r4, r4, #5	; 0x5
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  7a:	f06f 0003 	mvn.w	r0, #3	; 0x3
  7e:	fb00 3002 	mla	r0, r0, r2, r3
  82:	4649      	mov	r1, r9
  84:	4642      	mov	r2, r8
prvInitialiseTCBVariables():
C:\cortex\dimmers\rtos\src/tasks.c:1695
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  86:	6136      	str	r6, [r6, #16]
C:\cortex\dimmers\rtos\src/tasks.c:1698

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  88:	61b4      	str	r4, [r6, #24]
C:\cortex\dimmers\rtos\src/tasks.c:1699
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  8a:	6276      	str	r6, [r6, #36]
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:396

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
  8c:	f7ff fffe 	bl	0 <pxPortInitialiseStack>
  90:	6030      	str	r0, [r6, #0]
C:\cortex\dimmers\rtos\src/tasks.c:400

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
  92:	f7ff fffe 	bl	0 <vPortEnterCritical>
C:\cortex\dimmers\rtos\src/tasks.c:402
		{
			uxCurrentNumberOfTasks++;
  96:	4833      	ldr	r0, [pc, #204]	(164 <xTaskCreate+0x164>)
  98:	6ac3      	ldr	r3, [r0, #44]
  9a:	3301      	adds	r3, #1
  9c:	62c3      	str	r3, [r0, #44]
C:\cortex\dimmers\rtos\src/tasks.c:403
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  9e:	6ac3      	ldr	r3, [r0, #44]
  a0:	2b01      	cmp	r3, #1
  a2:	d126      	bne.n	f2 <xTaskCreate+0xf2>
C:\cortex\dimmers\rtos\src/tasks.c:406
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
  a4:	f8c0 609c 	str.w	r6, [r0, #156]
  a8:	f100 0438 	add.w	r4, r0, #56	; 0x38
prvInitialiseTaskLists():
C:\cortex\dimmers\rtos\src/tasks.c:1719

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  ac:	4f2d      	ldr	r7, [pc, #180]	(164 <xTaskCreate+0x164>)
C:\cortex\dimmers\rtos\src/tasks.c:1721
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  ae:	4620      	mov	r0, r4
  b0:	f7ff fffe 	bl	0 <vListInitialise>
  b4:	3414      	adds	r4, #20
C:\cortex\dimmers\rtos\src/tasks.c:1719

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  b6:	f107 039c 	add.w	r3, r7, #156	; 0x9c
  ba:	429c      	cmp	r4, r3
  bc:	d1f6      	bne.n	ac <xTaskCreate+0xac>
C:\cortex\dimmers\rtos\src/tasks.c:1724
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  be:	f107 05d4 	add.w	r5, r7, #212	; 0xd4
  c2:	4628      	mov	r0, r5
C:\cortex\dimmers\rtos\src/tasks.c:1725
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  c4:	f107 04e8 	add.w	r4, r7, #232	; 0xe8
C:\cortex\dimmers\rtos\src/tasks.c:1724
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  c8:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1725
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1726
	vListInitialise( ( xList * ) &xPendingReadyList );
  d2:	f107 0014 	add.w	r0, r7, #20	; 0x14
  d6:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1730

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  da:	f107 00b8 	add.w	r0, r7, #184	; 0xb8
  de:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1736
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  e2:	4638      	mov	r0, r7
  e4:	f7ff fffe 	bl	0 <vListInitialise>
C:\cortex\dimmers\rtos\src/tasks.c:1742
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  e8:	f8c7 50ac 	str.w	r5, [r7, #172]
C:\cortex\dimmers\rtos\src/tasks.c:1743
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  ec:	f8c7 40b0 	str.w	r4, [r7, #176]
  f0:	e009      	b.n	106 <xTaskCreate+0x106>
xTaskCreate():
C:\cortex\dimmers\rtos\src/tasks.c:418
			else
			{	
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  f2:	f8d0 30a8 	ldr.w	r3, [r0, #168]
  f6:	b933      	cbnz	r3, 106 <xTaskCreate+0x106>
C:\cortex\dimmers\rtos\src/tasks.c:420
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  f8:	f8d0 309c 	ldr.w	r3, [r0, #156]
  fc:	6adb      	ldr	r3, [r3, #44]
  fe:	455b      	cmp	r3, fp
C:\cortex\dimmers\rtos\src/tasks.c:422
					{
						pxCurrentTCB = pxNewTCB;	
 100:	bf98      	it	ls
 102:	f8c0 609c 	strls.w	r6, [r0, #156]
C:\cortex\dimmers\rtos\src/tasks.c:429
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 106:	4917      	ldr	r1, [pc, #92]	(164 <xTaskCreate+0x164>)
 108:	6af2      	ldr	r2, [r6, #44]
 10a:	f8d1 30fc 	ldr.w	r3, [r1, #252]
C:\cortex\dimmers\rtos\src/tasks.c:442
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
 10e:	4816      	ldr	r0, [pc, #88]	(168 <xTaskCreate+0x168>)
C:\cortex\dimmers\rtos\src/tasks.c:429
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 110:	429a      	cmp	r2, r3
C:\cortex\dimmers\rtos\src/tasks.c:431
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 112:	bf88      	it	hi
 114:	f8c1 20fc 	strhi.w	r2, [r1, #252]
C:\cortex\dimmers\rtos\src/tasks.c:440
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 118:	4912      	ldr	r1, [pc, #72]	(164 <xTaskCreate+0x164>)
 11a:	f8d1 30d0 	ldr.w	r3, [r1, #208]
 11e:	3301      	adds	r3, #1
 120:	f8c1 30d0 	str.w	r3, [r1, #208]
C:\cortex\dimmers\rtos\src/tasks.c:442

			prvAddTaskToReadyQueue( pxNewTCB );
 124:	6af2      	ldr	r2, [r6, #44]
 126:	6b4b      	ldr	r3, [r1, #52]
 128:	429a      	cmp	r2, r3
 12a:	bf88      	it	hi
 12c:	634a      	strhi	r2, [r1, #52]
 12e:	6af2      	ldr	r2, [r6, #44]
 130:	2314      	movs	r3, #20
 132:	fb03 0002 	mla	r0, r3, r2, r0
 136:	4651      	mov	r1, sl
 138:	f7ff fffe 	bl	0 <vListInsertEnd>
C:\cortex\dimmers\rtos\src/tasks.c:447

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 13c:	f7ff fffe 	bl	0 <vPortExitCritical>
C:\cortex\dimmers\rtos\src/tasks.c:457
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( ( void * ) pxCreatedTask != NULL )
 140:	9b0b      	ldr	r3, [sp, #44]
 142:	b103      	cbz	r3, 146 <xTaskCreate+0x146>
C:\cortex\dimmers\rtos\src/tasks.c:462
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 144:	601e      	str	r6, [r3, #0]
C:\cortex\dimmers\rtos\src/tasks.c:465
		}

		if( xSchedulerRunning != pdFALSE )
 146:	4a07      	ldr	r2, [pc, #28]	(164 <xTaskCreate+0x164>)
 148:	f8d2 30a8 	ldr.w	r3, [r2, #168]
 14c:	b133      	cbz	r3, 15c <xTaskCreate+0x15c>
C:\cortex\dimmers\rtos\src/tasks.c:469
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 14e:	f8d2 309c 	ldr.w	r3, [r2, #156]
 152:	6adb      	ldr	r3, [r3, #44]
 154:	455b      	cmp	r3, fp
 156:	d201      	bcs.n	15c <xTaskCreate+0x15c>
C:\cortex\dimmers\rtos\src/tasks.c:471
			{
				taskYIELD();
 158:	f7ff fffe 	bl	0 <vPortYieldFromISR>
 15c:	2001      	movs	r0, #1
C:\cortex\dimmers\rtos\src/tasks.c:477
			}
		}
	}

	return xReturn;
}
 15e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 162:	46c0      	nop			(mov r8, r8)
 164:	00000000 	.word	0x00000000
 168:	00000038 	.word	0x00000038
Disassembly of section .text.vTaskStartScheduler:

00000000 <vTaskStartScheduler>:
vTaskStartScheduler():
C:\cortex\dimmers\rtos\src/tasks.c:969
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
   0:	b513      	push	{r0, r1, r4, lr}
C:\cortex\dimmers\rtos\src/tasks.c:973
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
   2:	2400      	movs	r4, #0
   4:	2280      	movs	r2, #128
   6:	480b      	ldr	r0, [pc, #44]	(34 <vTaskStartScheduler+0x34>)
   8:	490b      	ldr	r1, [pc, #44]	(38 <vTaskStartScheduler+0x38>)
   a:	4623      	mov	r3, r4
   c:	9400      	str	r4, [sp, #0]
   e:	9401      	str	r4, [sp, #4]
  10:	f7ff fffe 	bl	0 <vTaskStartScheduler>
C:\cortex\dimmers\rtos\src/tasks.c:975

	if( xReturn == pdPASS )
  14:	2801      	cmp	r0, #1
C:\cortex\dimmers\rtos\src/tasks.c:973
void vTaskStartScheduler( void )
{
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
  16:	4602      	mov	r2, r0
C:\cortex\dimmers\rtos\src/tasks.c:975

	if( xReturn == pdPASS )
  18:	d10a      	bne.n	30 <vTaskStartScheduler+0x30>
C:\cortex\dimmers\rtos\src/tasks.c:985
		so interrupts will automatically get re-enabled when the first task
		starts to run.
		
		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  1a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
  1e:	f380 8811 	msr	BASEPRI, r0
C:\cortex\dimmers\rtos\src/tasks.c:987

		xSchedulerRunning = pdTRUE;
  22:	4b06      	ldr	r3, [pc, #24]	(3c <vTaskStartScheduler+0x3c>)
  24:	f8c3 20a8 	str.w	r2, [r3, #168]
C:\cortex\dimmers\rtos\src/tasks.c:988
		xTickCount = ( portTickType ) 0;
  28:	f8c3 40a4 	str.w	r4, [r3, #164]
C:\cortex\dimmers\rtos\src/tasks.c:992

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
  2c:	f7ff fffe 	bl	0 <xPortStartScheduler>
C:\cortex\dimmers\rtos\src/tasks.c:1002
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
  30:	bd1c      	pop	{r2, r3, r4, pc}
  32:	46c0      	nop			(mov r8, r8)
	...
